\documentclass[letterpaper,11pt]{article}
\usepackage{deauthor}
\usepackage{times}
\usepackage{graphicx} 
\usepackage{amssymb}	%
\usepackage{amsmath}

\usepackage{xcolor,colortbl}    %
%
%
%
%
%
%
%

%
%
%
%
%




\usepackage{xspace}            %

\newcommand{\queryvis}{\textsf{QueryVis}\xspace}
\newcommand{\diagrams}{\textsf{Relational Diagrams}\xspace}

\newcommand{\sql}[1]{\textup{\textsf{\small#1}}}



%
%
\usepackage{scalerel}
\usepackage{tikz}

\usetikzlibrary{svg.path}

\definecolor{orcidlogocol}{HTML}{A6CE39}
\tikzset{
  orcidlogo/.pic={
    \fill[orcidlogocol] svg{M256,128c0,70.7-57.3,128-128,128C57.3,256,0,198.7,0,128C0,57.3,57.3,0,128,0C198.7,0,256,57.3,256,128z};
    \fill[white] svg{M86.3,186.2H70.9V79.1h15.4v48.4V186.2z}
                 svg{M108.9,79.1h41.6c39.6,0,57,28.3,57,53.6c0,27.5-21.5,53.6-56.8,53.6h-41.8V79.1z M124.3,172.4h24.5c34.9,0,42.9-26.5,42.9-39.7c0-21.5-13.7-39.7-43.7-39.7h-23.7V172.4z}
                 svg{M88.7,56.8c0,5.5-4.5,10.1-10.1,10.1c-5.6,0-10.1-4.6-10.1-10.1c0-5.6,4.5-10.1,10.1-10.1C84.2,46.7,88.7,51.3,88.7,56.8z};
  }
}

\DeclareRobustCommand{\orcidiconlink}[2]{%
    \hypersetup{urlcolor=black}%
    \href{https://orcid.org/#2}{#1 \mbox{\scalerel*{%
        \begin{tikzpicture}[yscale=-1,transform shape]%
            \pic{orcidlogo};%
        \end{tikzpicture}%
    }{|}}}%
}%
%
%



%\usepackage[caption=false]{subfig} 
\usepackage{subfig}

\newcommand{\smallsection}[1]{\vspace{5mm}\noindent\textbf{#1.}}	%
\newcommand{\introparagraph}[1]{\textbf{#1.}}        %






%
%

\newtoks\bsubfloattoks
\newdimen\bsubfloatht

\makeatletter
\newenvironment{bsubfloatrows}[1][\quad]
  {\def\bsubfloatspace{#1}\resetbsubfloatrows
   \def\\{\printbsubfloatrow\resetbsubfloatrows\par
     \@ifnextchar[{\bsubfloatvspace}{}}%
   \def\bsubfloatvspace[##1]{\vspace{##1}}%
  }
  {\printbsubfloatrow}
\newcommand{\bsubfloat}[2][]{%
  \sbox\z@{#2}%
  \ifdim\bsubfloatht<\ht\z@
    \bsubfloatht=\ht\z@
  \fi
  \bsubfloattoks=\expandafter{\the\bsubfloattoks
    \bsubfloatspace\subfloat[#1]{\vbox to\bsubfloatht{\hbox{#2}\vfill}}}%
}
\newcommand\resetbsubfloatrows{\bsubfloatht\z@\bsubfloattoks={\@gobble}}
\newcommand{\printbsubfloatrow}{\the\bsubfloattoks}
\makeatother
%



%
%
%
%
\renewcommand\topfraction{1}
\renewcommand\bottomfraction{1}
\renewcommand\textfraction{0}            %
\renewcommand\floatpagefraction{1}
\renewcommand\dbltopfraction{1}
\renewcommand\dblfloatpagefraction{1}
\setcounter{totalnumber}{50} %
\setcounter{topnumber}{50} %
\setcounter{dbltopnumber}{50} %
\setcounter{bottomnumber}{50}


\usepackage{url}
\urlstyle{rm}

		

%
%
%
%
%
%\newtheorem{theorem}{Theorem}  	%
\newtheorem{scenario}{Scenario}              	
%\newtheorem{definition}{Definition}    %



%\usepackage[colorlinks, allcolors=blue]{hyperref}
\usepackage{hyperref}

\def\scenarioautorefname{Scenario}%
\def\subfigureautorefname{Figure}%
\def\subsectionautorefname{Section}%




\newcommand{\osfpreprintplain}{osf.io/btszh}
\newcommand{\osfsupplementplain}{osf.io/mycr2}
\newcommand{\osfpreregplain}{osf.io/mycr2}
\newcommand{\osfpreprint}{\formattedurl{https://\osfpreprintplain}{\osfpreprintplain}}
\newcommand{\osfpreprintlong}{\formattedurl{https://\osfpreprintplain}{https://\osfpreprintplain}}
\newcommand{\osfsupplement}{\formattedurl{https://\osfsupplementplain}{\osfsupplementplain}}
\newcommand{\osfsupplementlong}{\formattedurl{https://\osfsupplementplain}{https://\osfsupplementplain}}
%
\newcommand{\osfprereg}{\url{https://\osfpreregplain}}
\newcommand{\formattedurl}[2]{\href{#1}{\small\texttt{#2}}\xspace}



\graphicspath{{submissions/query-vis-gatterbauer/}}


\begin{document}

\title{Principles of Query Visualization}

\author{
  \hspace{-15mm}\phantom{x}
  \texorpdfstring{\orcidiconlink{Wolfgang Gatterbauer}{0000-0002-9614-0504}}{Wolfgang Gatterbauer}
  \hspace{-15mm}\phantom{x}  
  \\
  \hspace{-6mm}\phantom{x}
  Northeastern University
  \hspace{-6mm}\phantom{x}
  \\
  \footnotesize
  \hspace{-15mm}\phantom{x}
  w.gatterbauer@northeastern.edu
  \hspace{-15mm}\phantom{x}  
\and
  \texorpdfstring{\orcidiconlink{Cody Dunne}{0000-0002-1609-9776}}{Cody Dunne}\\
  \hspace{-6mm}\phantom{x}
  Northeastern University
  \hspace{-6mm}\phantom{x}
  \\
  \footnotesize
  \hspace{-15mm}\phantom{x}
  c.dunne@northeastern.edu
  \hspace{-15mm}\phantom{x}  
\and
  \texorpdfstring{\orcidiconlink{H.V.\ Jagadish}{0000-0003-0724-5214}}{H.V.\ Jagadish}\\
  \hspace{-6mm}\phantom{x}
  University of Michigan
  \hspace{-6mm}\phantom{x}
  \\
  \footnotesize
  jag@umich.edu
\and
  \hspace{-15mm}\phantom{x}
  \texorpdfstring{\orcidiconlink{Mirek Riedewald}{0000-0002-6102-7472}}{Mirek Riedewald}
  \hspace{-15mm}\phantom{x}  
  \\
  \hspace{-6mm}\phantom{x}  
  Northeastern University
  \hspace{-6mm}\phantom{x}
  \\
  \footnotesize
  \hspace{-15mm}\phantom{x}  
  m.riedewald@northeastern.edu  
  \hspace{-15mm}\phantom{x}  
}

\maketitle





\begin{abstract}
Query Visualization (QV) is the problem of transforming a given query into a graphical representation
that helps humans understand its meaning.
This task is notably different from designing a Visual Query Language (VQL)
that helps a user compose a query.
This article discusses 
the principles of relational query visualization
and its potential for simplifying user interactions with relational data.



\end{abstract}





\section{What is Query Visualization (QV) and what is it for?} 
\label{sec:1}



%
%
%
%
%
%
%

The design of relational query languages and the difficulty for users to compose relational queries have
received much attention over the 
last 40 years~\cite{DBLP:journals/vlc/CatarciCLB97, 
ChanUserDatabaseInterface:1993,
GREENE1990303,
Harel:Nonprocedural:1985,
FrameworkForChoosingQueryLanguages:1985,
LEGGETT1984493,
DBLP:journals/csur/Reisner81, 
Reisner1975:HumanFactors,
Welty-Stemple:1981,
scamell:1993}.
A complementary and much-less-studied problem is that of helping users 
\emph{read and understand an existing query}.  
Reading code is hard, and SQL is no exception.  
With the proliferation of public data sources, and associated queries, users increasingly have a need to read other people's queries and scripts.  
Furthermore, it is usually much easier to modify a draft than to write something from scratch.  
As such, modifying an already existing query could be an effective way to write new queries.
However, modifying an existing query requires first to understand it (\autoref{Fig_TheVision}). 
For these reasons, it is valuable to help users understand queries,
and visualization is one obvious route.
In this paper, we study the problem of query visualization with a view towards improving query understanding.


Consider the following five scenarios that illustrate how query visualizations can assist users:




\begin{scenario}[Data scientists reusing past queries]\label{scenario:1}
	A group of data analysts 
	are collaboratively analyzing movie data.
	This data is stored in a shared data repository. 
	In addition to the data itself, they are also sharing their queries using a Collaborative Query Management System (CQMS)
	\cite{QueRIERecommendations:2010,
	ARZAMASOVA2021101646,
	DBLP:conf/ssdbm/ChatzopoulouEP09,
	Eirinaki:QueRie:2014,
	DBLP:conf/icde/FanLZ11,
	HoweC2010:SQLshare, SQLshare:2016,
	DBLP:conf/cidr/KhoussainovaBGKS09, KhoussainovaKBS:2011, LiFWWF2011:DBease,
	Marcel:QueryRecommendations:2011,
	Milo:REACT:2016}.	
	The query recommendation component of that tool suggests relevant previously-issued queries that the user can choose from, 
	rather than write a query from scratch.
	The tool shows the queries both in text (\autoref{Fig_KevinBacon_a})
	and as query visualization (\autoref{Fig_KevinBacon_b}).
	The visualization preserves the logical structure of the textual query.
	 %
	 There is also a one-to-one mapping between the query and its visualization:
	%
	As the user moves the mouse over components of the visualization, the corresponding component in the textual query is highlighted (and v.v.).
	The particular query used in 
	\autoref{Fig_KevinBacon}
	is over the IMDB movie database and finds all actors with Kevin Bacon number 2
	(i.e.\
	actors who have not played in a movie with Kevin Bacon directly, 
	but who have played with other actors who have played with Kevin Bacon).\footnote{See \url{https://youtu.be/kVFnQRGAQls?t=170} for an animated explanation of how to read and understand  this particular query.}
	%
%
	These diagrams require some training to understand (see our discussion in \autoref{sec:2} for how to read them). 
	However, in a controlled and pre-registered user study  (see \autoref{sec:userstudy})
	we found that even a few minutes of training
	suffice, and experienced SQL users could interpret queries \emph{in less time} and \emph{with fewer errors} 
	using these diagrams instead of using SQL alone \cite{DBLP:conf/sigmod/LeventidisZDGJR20}.




	A widely known example of such a shared data and query repository is the Sloan Digital Sky Survey (SDSS)~\cite{QueRIERecommendations:2010, SDSS}.
	Data about stars was put into a relational database and is freely available for access. 
	%
	Astronomers, who are mostly ``hobbyist" SQL users, 
	have to write queries to get the data they want.
	In most cases, the queries they wish to write are similar to queries others have written before.  So the standard workflow is for the user 
	%
	to look at previously issued queries, find one that is close to what they want, and then modify it to suit their analysis needs.
	In response, SDSS has added templates for commonly written query types.\footnote{\url{http://skyserver.sdss.org/dr8/en/help/docs/realquery.asp}} 
	
		%
	%


	%
	%
	%
	%
	%
\end{scenario}

	%
	%
	%


	%
	%




\begin{figure}[t]
%
   \centering
\subfloat[SQL query]{
	\includegraphics[scale=0.58]{figs/Fig_KevinBaconNew_a}
	\label{Fig_KevinBacon_a}}
\hspace{4mm}
\subfloat[Query Visualization]{
	\includegraphics[scale=0.58]{figs/Fig_KevinBaconNew_b}
	\label{Fig_KevinBacon_b}}	
%
	\caption{\autoref{scenario:1}: A user searches for a query by browsing through a repository 
	of previously-recorded SQL queries.
	For each query, she needs to \emph{quickly understand} its meaning. 
	A query visualization panel helps her understand the query by showing a 
	succinct representation of its relational query pattern. 
	The shown query returns actors with Bacon number 2.
	As she hovers her mouse over parts of the query, 
	both the textual and visualized query highlight corresponding parts in synchronization.
		%
		%
	%
}
\label{Fig_KevinBacon}
\end{figure}



\begin{scenario}[Visual feedback during query editing]
	As the user starts editing the SQL query (\autoref{Fig_KevinBacon_a}), the query visualization gets updated too
	(\autoref{Fig_KevinBacon_b}, updates are not shown).
	When a syntactically-correct query does not give the expected result,
	the query visualization can help the user understand that an incorrect join pattern was used between the various subqueries. 
		%
		%
\end{scenario}	








\begin{scenario}[Learning from galleries of relational query patterns]
	A data scientist wants to issue another query and looks for inspiration in a \emph{web gallery of SQL design patterns}.
	Similar to the way users of Matplotlib\footnote{\url{https://matplotlib.org/stable/gallery/index.html}},
	 D3\footnote{\url{https://d3-graph-gallery.com/}}, 
	and Altair\footnote{\url{https://altair-viz.github.io/gallery/index.html}} 
	%
	program new visualizations by browsing through, copying from, and adapting existing designs~\cite{10.1145/3503490}, 
	such galleries enhance the technical skills of data scientists and learners by 
	showing a range of possible relational patterns and design templates to learn from 
	that would be hard to browse and make sense of 
	based on text alone.
	Similar programmer behaviors are found outside of visualization, where existing code templates, examples, and idioms are extensively copied and adapted.
	%
	From IDE (Integrated Development Environment) logs of 81 developers, 
	Ciborowska et al.\ \cite{Ciborowska2018} identified many cases of opportunistic code reuse from the Web
	followed by editing the code. 
	%
	%
	LaToza et al.~\cite{Latoza2006} surveyed 157 programmers, 
	%
	and 56\% agreed that understanding code that someone else wrote is a serious problem.
	Yang et al.~\cite{Yang2017} found that many blocks of Python code are copied from Stack Overflow 
	into open-source projects with slight modifications. 
	Ahmed et al.~\cite{Ahmed2015} found that 24\%
	of copy-and-paste events 
	%
	%
	among 21,770 users of Eclipse were from sources external to the IDE, though this is likely an overestimate. 
	Brandt et al.~\cite{Brandt2009} found that such copy-and-paste programming is particularly beneficial for programmers working in new domains:
	In their study of students learning to use a new framework, one-third of the participants' code consisted of modified versions of examples from the documentation. 
	%
	%

	
	
	%
	
%
		%
		%
		%
		%
		%


		%
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
        %
	%
	%
	
		%
		%
		%
		%
\end{scenario}	


\begin{scenario}[Clustering pattern-identical queries]
	A teacher receives the SQL solutions for a homework from her 50 students. 
	An automatic correction tool, such as
	ADUSA~\cite{DBLP:conf/kbse/KhalekELK08},
	Cosette~\cite{DBLP:conf/cidr/ChuWWC17},
	Qex~\cite{DBLP:conf/lpar/VeanesTH10}
	TATest~\cite{MRJ:ExplainingWrongQueries:2019},
	or XData~\cite{DBLP:journals/vldb/ChandraCKRS015},
	%
	%
	determines that 40 of those solutions are correct. But those correct solutions ``look'' very different,
	even after applying some standard SQL pretty printer,
	such as sqlparse~\cite{sqlparse}.
	%
	%
	%
	%
	%
	%
	%
	The queries use different table aliases, nesting patterns, join sequences, and at times different syntactic constructs, 
	such as
	implicit joins in the WHERE clause
	or infixed SQL-92 join notation.
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	The teacher would like to cluster the 40 correct solutions not by their syntactic variants, but 
	%
	by whether there
	%
	are `truly' 
	\emph{novel patterns} beyond the 3 she currently knows.
		%
		%
		%
		%
		%
		%
		%
		%
		%
	Query visualization makes it easier to cluster and compare the 40 queries, because a good visualization
	captures the essence of the query structure, abstracting away superficial
	syntactic differences.	
	And, indeed, the teacher finds 2 new patterns.
	She can now show and discuss 5 total patterns with the learners in the next class.
\end{scenario}	





\begin{scenario}[Visual feedback from voice assistants]
	\label{scenario:5}
	We now switch to the year 2045.
	%
	A data analyst 
	stands in her office analyzing some company data. 
	She directs possible queries to her voice assistant 
	which then visualizes on the walls the queries 
	together with the data (\autoref{Fig_SpeechAssistant}). 
	The visualization of the query provides immediate feedback on what the assistant understood.
\end{scenario}



	%
	%
	%
	%
	%
	%


\begin{figure}
    \centering
    \begin{minipage}{0.5\textwidth}
        \centering
        \includegraphics[scale=0.425]{figs/Fig_TheVision}
		\caption{The goal of query visualization is to complement (but not substitute) the composition of queries 
		by creating automatic visualizations of queries. 
		Composition of a query is still performed via unambiguous and expressive text. 
		The transformation from text into a visualization can abstract away from a concrete syntax and thus be non-injective. 
		Compare to the write-format-preview cycle used by LaTeX~\cite{latex} in that a user writes text, 
		the system then autoformats and renders a document, 
		which the user can then peview.
		%
		%
		%
		}
		\label{Fig_TheVision}
    \end{minipage}
	\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[scale=0.36]{figs/Fig_SpeechAssistantv2}
		\caption{\autoref{scenario:5}: An analyst dictates queries to her voice assistant which then shows the query as understood 
		together with the query answers.}
		\label{Fig_SpeechAssistant}
    \end{minipage}
\end{figure}


	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%




Common to these 5 scenarios is that query visualization helps the users achieve new functionalities 
or increased efficiency in composing queries
as a \emph{complement} to query composition and 
\emph{not a substitute} for it.
%
	%
	%
	%
%
%
	%
	%
	%
	%


\begin{definition}[Query Visualization]
The term ``query visualization'' refers to both ($i$) a graphical representation of a query 
and ($ii$) the process of transforming a given query into a graphical representation.
The goal of query visualization is to help users more quickly understand the intent of a query,
as well as its relational query pattern.
\end{definition}

When we say ``query visualization", we will typically mean the end result. 
From context, it should be clear to the reader on the few occasions when we mean the process rather than the end result.

	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%

	%
	%
	%
	%
	%
	%
	%











\section{What Query Visualization is not}
\label{section:whatisQVnot}


\subsection{Query Visualization is not the same as a Visual Query Language (VQL)}
\label{QVisnotVQL}

Visual Query Languages (VQLs) provide languages to express queries in a visual format.
Visual Query Systems (VQSs) implement VQLs and generate queries from visual representations constructed by users~\cite{DBLP:reference/db/Catarci18a}.
Such visual methods for specifying relational queries have been studied
extensively
(a 1997 survey by Catarci et al.~\cite{DBLP:journals/vlc/CatarciCLB97} 
cites over 150 references), and
many commercial database products offer some visual interface for users to write SQL queries.  
In parallel, there is a centuries-old history on the study of formal diagrammatic reasoning systems \cite{DBLP:conf/iccs/Howse08}
with the goal of helping humans to reason in terms of logical statements.\footnote{A relational query is a logical formula with free variables. 
A logical statement has no free variables and is intuitively the same as a Boolean query that returns a truth value of TRUE or FALSE. }
Yet despite their extensive study and intuitive appeal, successful visual tools today mostly only 
\emph{complement instead of 
replace}
%
text for specifying queries.
Why has visual query specification not yet replaced textual query specification?




\begin{figure}[t]
\centering
\begin{minipage}{0.50\textwidth}
	\includegraphics[scale=0.35]{figs/Fig_MatrixDataQueryNew}
	\caption{%
	    \emph{Composing} a query with a visual query language is as sequential as composing it with SQL. 
        \emph{Interpreting} a visualization (whether of information or a query) 
		is the only modus in which a user can act on information in parallel, 
		leveraging the speed of the human perceptual system 
		(orange = easier, blue = harder).
    }
    \label{Fig_MatrixDataQueryNew}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
	\includegraphics[scale=0.35]{figs/Fig_MatrixTextGraphicsNew}
	\caption{%
	    \emph{Visual Query Languages} allow a user to compose queries. 
		They have been widely studied and have a rich history.
	    In contrast, \emph{Query Visualization} helps the user understand an existing query 
		just as \emph{Information Visualization} helps understand data 
		(orange = easier, blue = harder).
    }
	\label{Fig_MatrixTextGraphics}
\end{minipage}
\end{figure}




We believe that there are two primary reasons:
(1) First, humans are \emph{better in interpreting rather than composing visuals} because visual composition is an inherently sequential process (\autoref{Fig_MatrixDataQueryNew}).
All human input methods (composition) are sequential, whether resulting in text or a graphic. Visual perception is a remarkable human sense (interpretation) that can 
understand inputs
in parallel,
%
and it works dominantly by \emph{spatial arrangement of information}. 
While reading text is also a visual activity, the spatial arrangement of the letters requires a sequential scan of the text 
(though notice that pretty printers can spatially arrange text, \autoref{section:alternatives}).
Hence, visual interpretation of graphics is the fastest way to communicate with humans, 
and it only works well for understanding rather than composing.
Even in theory, there is no dramatic speed-up 
%
in
using a visual language for composition. 
In practice, the user interaction is quite cumbersome: 
users must be able to interactively construct and manipulate expressions in a visual language and connect graphical elements 
to establish graphical relationships. In turn, the program must provide appropriate interpretations
 of mouse, touch, and keyboard events, 
 and it is difficult to build formal grammars and compilers for two-dimensional drawing areas. 
In sum, solutions to these graphical requirements are intricate, inherently difficult to implement, and challenging to use~\cite{Zhang:2007zr}. 
%








(2) A second reason is that graphs are more ambiguous than text, i.e.\ it is more difficult to be precise with a visual representation than with text. 
In order to precisely specify a query, possible options
and specific details affecting query semantics must be presented. 
In contrast, 
understanding a query requires a focus on the high-level structure, abstracting
away low-level details and subtleties. 
In programming languages, this distinction is clearly made between \emph{visual programming} for developing a program
and \emph{program visualization} for analyzing an existing program~\cite{MYERS199097}.
%
%






This leads us to suggest a user-query interaction 
that separates the query composition from the visualization (\autoref{Fig_TheVision}):
Composition is unchanged and best done in text 
(or alternatively with exploratory input
formats like natural language).
But composition is augmented and \emph{complemented with a visual that helps interpretation}. 
%
%
%
%
%
%
Recall \autoref{scenario:5} where a digital voice assistant connects to omnipresent screens to show what it understood before executing a command (\autoref{Fig_SpeechAssistant}).
Compare to the way that many of us write research papers: we write LaTeX code in a text editor but prefer to read and verify the auto-compiled PDF using automatic or editor-specific build instructions (\autoref{Fig_TheVision}).
%
	%
	%

Finally notice that query visualization is related to \emph{Information Visualization}~\cite{Chen:2006vn},
which also focuses on helping users understand complex relationships, 
but in data instead of in query logic~(\autoref{Fig_MatrixTextGraphics}).

	%
	%
	%
	%
	%



	%

	%
	%








\subsection{Query Visualization is not the same as Query Plan Visualization}
\label{sec:queryplans}

Readers may be familiar with visualizations of query plans.
\autoref{Fig_explain_PersonBarDrink} shows a query plan chosen by PostgreSQL~\cite{postgres}
to run query $Q_{\textrm{some}}$ from \autoref{figure:sql_conjunctive} 
(\emph{Find persons who frequent some bar that serves a drink they like}).
Similarly, \autoref{Fig_DFQL_Drinkers} shows the same query expressed 
in DFQL (Dataflow Query Language) \cite{DBLP:journals/iam/ClarkW94} which is modeled after relational algebra.
Notice that neither visualization captures the cyclic nature of the joins in query $Q_{\textrm{some}}$.
%
A query plan visualization attempts to represent HOW a query is executed.
In contrast, a query visualization attempts to represent WHAT a query does (i.e.\ its intent) and possibly the relational pattern it uses.
See the query visualization in \autoref{Fig_ExampleExists} which shows the join pattern and that this query is cyclic.
Similarly, query visualizations are also different from 
visualizing and comparing the cost or speed of execution plans~\cite{DBLP:journals/pvldb/Haritsa10}. 










\subsection{Query Visualization is only partially related to Visal Query Debugging} 
\label{sec:querydebugging}

%

An important reason for why we want to help users understand HOW exactly a given query is executed
is for debugging a faulty query.
Visualizing software execution behavior
can be helpful for program debugging
\cite{DBLP:conf/chi/GathaniLB20,DBLP:journals/vlc/Reiss07},
but only if it helps explain WHY a query returns a particular result or WHY NOT~\cite{DBLP:conf/mud/MeliouGMS10}.
To achieve this more fine-grained understanding, state-of-the-art workflows for debugging SQL queries help users understand 
queries by somehow \emph{showing intermediate results}~\cite{
GrustKRS2011:SQLdebugging,
DBLP:journals/tods/GrustR13,
MRJ:ExplainingWrongQueries:2019,
DBLP:conf/sigmod/OlstonCS09}.
Thus it is helpful to see debugging as a spectrum of goals with different ``granularities.''
%
At one end of the spectrum, a query may be faulty because two incorrect tables are joined 
(a tool that answers WHAT the query actually does would help here).
At the other more-fine grained level, a query may be faulty because a DMBS implemented a particular SQL syntax for handling NULLS incorrectly\footnote{As example see \url{https://stackoverflow.com/questions/19686262/query-featuring-outer-joins-behaves-differently-in-oracle-12c}}, 
and it seems there is no way to avoid using data examples for effective debugging.





%
%
%
%
%



\begin{figure}[tb]
    \centering
	\subfloat[Postgres EXPLAIN command for $Q_{\textrm{some}}$]{
	\includegraphics[scale=0.5]{figs/Fig_explain_PersonBarDrink}
	    \label{Fig_explain_PersonBarDrink}
	}
	\hfill
	\subfloat[$Q_{\textrm{some}}$ in DFQL]{
	\includegraphics[scale=0.5]{figs/Fig_DFQL_Drinkers}
	    \label{Fig_DFQL_Drinkers}	
	}
    %
    %
    %
    %
    %
    %
    \caption{
	Query visualizations are not query plans nor data flow diagrams:
	(a) Visualized query plan by Postgres' EXPLAIN command~\cite{postgres} for query $Q_{\textrm{some}}$ from \autoref{figure:sql_conjunctive}.
	(b) Same query expressed in DFQL (Dataflow Query Language) \cite{DBLP:journals/iam/ClarkW94} which is modeled after relational algebra.
	Notice that neither visualization captures the cyclic nature of the joins 
	(see \autoref{Fig_ExampleExists}).
	%
	``\emph{Query visualization}'' to ``\emph{query plan visualization}'' 
	is the same as
	``\emph{intend of a query} (WHAT)'' to ``\emph{execution of a query} (HOW)''.
		} 
    \label{Fig_explain_PersonBarBeer}
\end{figure}




\subsection{Alternatives to Query Visualization for helping users understand existing queries} 
\label{section:alternatives}

There are three main alternative approaches for helping users understand existing queries:


\textbf{(1) Illustrating queries by examples}. 
Several papers suggest illustrating the semantics of operators in a data flow program or the semantics of queries by generating 
\emph{example input and output data}, and possibly \emph{intermediate data}.
The result is basically a list of tuples for each relational operator~\cite{DBLP:conf/uist/AbouziedHS12,
DBLP:journals/vldb/ChandraCKRS015,
GrustKRS2011:SQLdebugging,
DBLP:journals/tods/GrustR13,
DBLP:journals/pvldb/KhanX0H17,
MRJ:ExplainingWrongQueries:2019,
DBLP:conf/sigmod/OlstonCS09}.
%




	%
	%






\textbf{(2) Translating queries into Natural Language (NL)}.
Translating between SQL and NL is a heavily researched topic, and various ideas are proposed to explain queries in NL~\cite{DBLP:conf/inlg/GehrmannDER18,
DBLP:conf/nldb/Ioannidis08, 
DBLP:conf/icde/KoutrikaSI10,
DBLP:conf/cidr/SimitsisI09, 
DBLP:conf/emnlp/XuWWFS18}. 
Work in this area convincingly argues that automatically creating effective free-flowing text from queries is difficult and that the overall task is quite different from previous work on creating NL interfaces to DBMSs~\cite{Jarke:NL:1985}.
There is also recent work on translating query plans into NL~\cite{DBLP:conf/sigmod/WangBLJLC21}.





\textbf{(3) Pretty printing queries}.
Query editors for major DBMSs use 
\emph{syntax highlighting
and aligning} 
%
of query blocks and clauses. 
Pretty printers, such as sqlparse~\cite{sqlparse}, automatically arrange a SQL query in a supposedly easy-to-read form.
The most important dimensions are colors, capital vs.\ small letters, and indentation.



%
%
%
%
%
%
%
%
%
%
%
%
%
%



	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%


A key difference of alternatives to query visualization is 
that they are all inherently linear.
A list of tuples or a textual description do not readily reveal common logical pattern behind queries.
In particular, we are not aware of any SQL to NL tool available today that could translate our example from 
\autoref{fig:beerquery}
into an intuitive NL representation.
Patterns are naturally best shown visually,
%
and even the programming design patterns book~\cite{Gamma:1995ys} illustrates its patterns with intuitive diagrams.
A theory of relational query patterns, and a query-user interaction pattern inspired by ``mix-and-match'',
seems naturally supported by a visual approach.
	%
	%
	%
In addition, our recent work \cite{relationalDiagrams} has shown that certain types of relational patterns 
cannot be represented in an operator-style (thus sequential) model.


%











\section{Principles of Query Visualization and Design trade-offs} 
\label{sec:2}



%
%
The challenge of query visualization is to find appropriate visual metaphors 
that ($i$) allow users to quickly understand a query's intent, even for complex queries,
($ii$) can be easily learned by users,
and ($iii$) can be obtained from SQL by automatic translation, including a visually-appealing automatic arrangement of nodes of the visualization.
We believe that---with the right visual alphabet---users can learn to interpret visualized queries by seeing examples without much active focus. This is similar to what is known in language learning theory as the difference between the active and the generally larger passive vocabulary: Actively reproducing newly learned content is generally more difficult than passively recognizing such content. 


We next discuss the principles that led us to a particular design of a query visualization language (actually two variants, which we discuss later in more detail). We list those here to spark a healthy debate. Not all listed principles are universal, and deviations may lead to interesting alternative design decisions. These principles are also not MECE (Mutually Exclusive and Collectively Exhaustive), and some design decisions can be justified separately from other overlapping decisions.







\begin{figure}[tb]
\centering
\begin{bsubfloatrows}[\hspace{20mm}]
\bsubfloat[$Q_{\textrm{some}}$ in SQL]{%
	%
	\textup{\textsf{
	\footnotesize
	\setlength{\tabcolsep}{1mm}
	\begin{tabular}[t]{@{} l l l l l}
			& \\
			& \textcolor{blue}{select distinct} F.person\\
			& \textcolor{blue}{from}	Frequents F, Likes L, Serves S\\
			& \textcolor{blue}{where}	F.person = L.person \\ 
			& \textcolor{blue}{and}		F.bar = S.bar \\ 					
			& \textcolor{blue}{and}		L.drink = S.drink
	\end{tabular}
	}}	
	%
\label{figure:sql_conjunctive}	
}
\bsubfloat[$Q_{\textrm{some}}$ in \queryvis]{%
    \includegraphics[scale=0.4]{figs/Fig_ExampleExists}
    \label{Fig_ExampleExists}
}
\end{bsubfloatrows}
\caption{Principles 1 \& 2:
Visualizing a conjunctive query should follow a familiar UML notation:
\emph{Find persons who frequent some bar that serves some drink they like}. 
The only novelty is a dedicated output table on the left,
emphasizing the compositionality of the relational model, 
and supporting an output-oriented reading order.
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
}
%
\end{figure}





\textbf{(1) Existing metaphors as starting point}: 
Ideally, a query visualization can be learned ``on-the-fly'' by seeing visualizations of increasing complexity, starting from examples that are already familiar.
Most database users are familiar with the UML diagram notation for classes and their attributes~\cite{folwer:UMLdistilled:2003}
applied to database schemas: Table names on top of column names in rectangular bounding boxes, 
primary-foreign keys contraints represented by lines between column names.
The visualization of a conjunctive query should thus not depart too much from 
such deeply familiar visual metaphors
%
(e.g., see the conjunctive query $Q_{\textrm{some}}$ in \autoref{figure:sql_conjunctive}
and its visualization in \autoref{Fig_ExampleExists}).
%
More complicated queries then progressively extend such familiar visual metaphors.




\begin{figure}[t]
\centering
 \parbox{.34\textwidth}{	
    \subfloat[$Q_{\textrm{only}}$]{
        %
		\textup{\textsf{
		%
		\footnotesize
		\setlength{\tabcolsep}{1mm}
		\begin{tabular}{@{} l l l l l}
		\\[17mm]			
			& \multicolumn{4}{l}{\textcolor{blue}{select distinct} F.person}\\
			& \multicolumn{4}{l}{\textcolor{blue}{from}		Frequents F}\\
			& \multicolumn{4}{l}{\textcolor{blue}{where}	not exists} \\ 
			& \phantom{xx}	& \multicolumn{3}{l}{(\textcolor{blue}{select} 	*}\\
			& 	 			& \multicolumn{3}{l}{\textcolor{blue}{from}		Serves S}\\
			& 	 			& \multicolumn{3}{l}{\textcolor{blue}{where}	S.bar = F.bar}\\
			& 	 			& \multicolumn{3}{l}{\textcolor{blue}{and}		not exists}\\
			&				& \phantom{xx}	& (\textcolor{blue}{select} 	L.drink \\
			&				& 				& \textcolor{blue}{from}	Likes L \\
			&				& 				& \textcolor{blue}{where} 	L.person = F.person \\
			&				& 				& \textcolor{blue}{and} 	S.drink = L.drink))		
		\\[15mm]
		\end{tabular}
		}}	
		\label{figure:sql_nested}
    }
    %
	%
}
 \parbox{.63\textwidth}{	
    \subfloat[$Q_{\textrm{only}}$]{
        \includegraphics[scale=0.4]{figs/Fig_ExampleNotExists}
        %
        %
	}
    \hspace{1mm}
    \subfloat[$Q_{\textrm{only}}$]{
        \includegraphics[scale=0.4]{figs/Fig_ExampleAll}
        %
        \label{Fig_ExampleAll}
	}
    \hspace{1mm}
    \subfloat[$Q_{\textrm{only}}$]{
        \includegraphics[scale=0.4]{figs/Fig_ExampleNotExistsRD}
        \vspace{1mm}
        \label{Fig_ExampleNotExistsRD}
	}
    \hspace{4mm}	
    \subfloat[$Q_{\textrm{only}}$]{
        \includegraphics[scale=0.4]{figs/Fig_ExampleNotExistsRDShaded}
        \vspace{1mm}
        \label{Fig_ExampleNotExistsRDShaded}
	}		
}      
    \caption{
	Principles 3 \& 8:
	(a) \emph{Find persons who frequent some bar that serves 
	ONLY drinks they like}. 
	\queryvis:
	(b) Visualizing a nested query still follows familiar UML notations, 
	but now adds visual metaphors for $\nexists$ (dashed box) and 
	the reading order can be found by following the arrows.
	%
	%
	%
	%
	%
	%
	%
	%
	%
	(c) The reading can be further simplified by the use of the $\forall$ quantifier 
	(double-lined bounding box), a logical and intuitive operator that does not exist in SQL.
	The visualization asks for \emph{persons who frequent some bar so that 
	{ALL} drinks served are liked by them}.
	\diagrams are an alternative visualization that replaces arrows and reading orders by 
	explicit enclosure to express nesting relationships (d) and (e).
	}
    \label{Fig_ExampleVisualizations}
\end{figure}

%





\textbf{(2) Compositionality of the relational model}:
Inputs to queries are tables, and the output of a query is another table. 
Visualizations can (and we think should) emphasize this compositionality by explicitly showing an output table. 
This compositionality is also illustrated by the Relational Tuple Calculus expression for \autoref{figure:sql_conjunctive}:
\begin{align*}
	\{ q(\textit{person}) \mid \;
	& \exists f \in \textit{Frequents}, \exists l \in \textit{Likes}, \exists s \in \textit{Serves} 
	[
	q.\textit{person} = f.\textit{person} \wedge \\
	& 	
	f.\textit{person} = l.\textit{person} \wedge 
	l.\textit{drink} = s.\textit{drink} \wedge 	
	s.\textit{bar} = f.\textit{bar}
	] \}	
	%
\end{align*}
The expression makes use of 4 tables: 3 input tables (\textit{Frequents}, \textit{Likes}, and \textit{Serves}), and 1 output table called~$q$
(\autoref{Fig_ExampleExists} names the output table ``SELECT'').
In contrast, all interactive query tools listed in \autoref{sec:relatedWork} use either checkmarks, stars, or colors
%
to highlight a subset of attributes that are returned by the query.










\textbf{(3) Progressive visual complexity}: 
%
Entropy codes, such as Huffman codes~\cite{cover:thomas:2006}, 
compress data by encoding symbols with an amount of bits inversely proportional to the frequency of the symbols.
%
%
%
%
%
%
%
%
%
%
In the same spirit, a visual alphabet should be adapted to an overall expected workload and visual constructs for more common logical operators should be designed with lower visual complexity than less common ones. 
Starting from UML and its familiar notations for schemas and conjunctive queries, 
we can then enhance the visual representation in a \emph{progressive way}. 
For example, almost all database queries use the logical AND in their first-order logic translation (e.g.\ joins, \sql{EXISTS}, \sql{IN}), but only few use OR (e.g.\ \sql{OR}, \sql{UNION}). 
If infrequent query constructs become increasingly complex to read, this progression does not decrease the overall usability, but rather assures that more often used constructs are simple to read, in turn.
%
For example, the visualization of the query from \autoref{figure:sql_nested}
is expected to be at least as ``complicated'' as the query from \autoref{figure:sql_conjunctive}.

For increasing complexity of nested queries with negation, we are inspired by a body of work on \emph{diagrammatic reasoning systems}~\cite{DBLP:conf/iccs/Howse08}. 
Diagrammatic notations are in turn inspired by the influential \emph{existential graph notation} by Charles Sanders Peirce~\cite{peirce:1933,Roberts:1992,Shin:2002}.
These graphs exploit topological properties, such as enclosure, to represent logical expressions and set-theoretic relationships
%
%
(see description in \autoref{Fig_ExampleVisualizations}).






	%


	%









\textbf{(4) Expose (and not hide) relational patterns}:
We believe that a query visualization should expose the relational pattern used in a textual query,
instead of replacing it with an abstraction and concepts that go beyond the relational model.
This requires a visualization to use the same number of input tables of the textual query 
and to preserve a 1-to-1 mapping between them.
To illustrate, consider the SQL query in
\autoref{Fig_uniqueDrinkerTastSQL} asking for ``persons with a unique drink taste.''
The query uses 6 instances of the same table in a pattern that reads
``return any person, s.t.\ there does not exist any other person, s.t. there does not exist any drink liked by that other person 
that is not also liked by the returned person and there does not exist any drink liked by the returned person that is not also liked by the same other person.''
The visualization in \autoref{Fig_uniqueDrinkerTastQV1}
does not replace that relational pattern with another shorter construct, but rather 
makes it easier to inspect and reason about:
it complements the textual query
and preserves some traceable mapping between query and visualization. It preserves its relational pattern.







\begin{figure}[t]
\centering
\subfloat[SQL query]{
	\includegraphics[scale=0.4]{figs/Fig_uniqueDrinkerTasteSQL}
	\label{Fig_uniqueDrinkerTastSQL}}
\hspace{10mm}
\subfloat[Query Visualization]{
	\includegraphics[scale=0.45]{figs/Fig_uniqueDrinkerTastQV1}
	\label{Fig_uniqueDrinkerTastQV1}}	
%
%
%
%
\caption{Principles 4 \& 5: 
(a) Unique-set-query ``\emph{Find person with a unique drink taste}.''
(b)~\queryvis diagram with reading order encoded by arrows 
(please see \cite{DBLP:conf/sigmod/LeventidisZDGJR20} for a detailed discussion of the query and its visualization).
There is a 1-to-1 correspondence between the SQL query and its visualization. 
As the user moves the mouse over fragments of the query, the graphical representation highlights the corresponding visual elements.
%
%
%
%
%
}
\label{fig:beerquery}
\end{figure}









\textbf{(5) Minimal visual complexity}: 
A query visualization should fulfill some kind of minimality criteria.
Intuitively, we aim to minimize the ink-data ratio 
(thus we like to maximize its inverse: Edward Tufte's famous data-ink ratio defined as the proportion of a graphic’s “ink” devoted to the informative and thus non-redundant display of data information~\cite{tufte2001visual}).
	%
	%
Minimality can be interpreted in different ways:
For example, the visual alphabet could contain only a minimal set of different visual elements; removing an element would then render the visualization less expressive.
Or, for a given query, removing a particular visual element would render the query incomplete.
To achieve such minimality, one can take inspiration by comparative analysis of existing textual languages.
For example, 
($i$) Datalog does not require the use of table aliases (different occurrences of the same input relation can be distinguished by their join patterns), whereas SQL requires alias.
On the other hand, ($ii$) SQL (inspired by tuple relational calculus) does not reference any attribute that is not used by the query,
whereas Datalog uses positional information and thus requires to maintain positional information.
\autoref{Fig_uniqueDrinkerTastQV1}
shows an example \queryvis visualization that combines the best of both worlds: 
($i$) repeated relations do not require aliases, 
and ($ii$) each of those occurrences only displays attributes needed.\footnote{A visualization could still show aliases to make it easier to maintain a static correspondence between the query and it visualization. However those aliases are not needed to interpret the meaning of a visual diagram.}

	%
	%
	%
	%
	%
	%
	%











\textbf{(6) Abstract away from syntax details}:
%
A query visualization abstracts away from language-specific peculiarities.
It can thus be non-injective with regard to syntactic redundancy.
A prominent example is SQL's use of NULLs. 
While there has been a lot of work on putting SQL's use of NULL values on solid foundations,
there is no universally agreed standard, and 
SQL queries evaluated on databases with NULL ``may produce answers that are just plain wrong''~\cite{DBLP:journals/sigmod/GuagliardoL17}.
The goal of query visualization can't be to provide an unambiguous interpretation of queries in the presence of NULLs, 
and thereby as a side-product also fix issues that have vexed database theoreticians over decades.
Rather, the focus of query visualization on the underlying relational patterns means that query visualizations 
need to abstract away from such oddities and not preserve them
(see \autoref{Fig_CompleteExampleAmbiguous}).
Also, a query visualization is meant to complement a textual original query.
It thus does not have to preserve all the information from the query; it can be non-injective,
thereby dividing the work: a visualization for the overall pattern, the text for the details.
This point goes back to \autoref{section:whatisQVnot} and what query visualization does not try to achieve.
	%
The focus is on WHAT a query does, 
yet confined to the relational model and the particular underlying relational pattern
(including all the input tables used), not the syntax nor the HOW of a particular execution plan.
Tools that help users cope with the inherent syntactic difficulty of SQL fall under the category of SQL debugging (\autoref{sec:querydebugging}).
The common foundation of all relational query languages and the relational model is
First-Order Logic.
%
%
%
%
We thus believe that focusing on the \emph{logical interpretation} of queries~\cite{DBLP:journals/bsl/HalpernHIKVV01} and set semantics 
provides a solid and well-understood foundation for query visualization.
See \autoref{Fig_CompleteExampleAmbiguous} for an example.





	%


	%
	%







	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%






\begin{figure}[tb]
\centering
\begin{bsubfloatrows}[\hspace{20mm}]
\bsubfloat[]{%
	%
	\textup{\textsf{
	\footnotesize
	\setlength{\tabcolsep}{1mm}
	\begin{tabular}{@{} l l l l l}
	%
	%
		& \multicolumn{4}{l}{\textcolor{blue}{select distinct} A}\\
		& \multicolumn{4}{l}{\textcolor{blue}{from}		R}\\
		& \multicolumn{4}{l}{\textcolor{blue}{where}	B not in} \\ 
		& \phantom{xx}	& \multicolumn{3}{l}{(\textcolor{blue}{select} 	C}\\
		& 	 			& \multicolumn{3}{l}{\textcolor{blue}{from}		S)}
	\\[23mm]
	\\
	\end{tabular}
	}}	
	%
\label{Fig_IntroductionExample_b_table}	
}
\bsubfloat[]{%
	%
	\textup{\textsf{
	\footnotesize
	\setlength{\tabcolsep}{1mm}
	\begin{tabular}{@{} l l l l l}
	%
	%
		& \multicolumn{4}{l}{\textcolor{blue}{select distinct} A}\\
		& \multicolumn{4}{l}{\textcolor{blue}{from}		R}\\
		& \multicolumn{4}{l}{\textcolor{blue}{where}	not exists} \\ 
		& \phantom{xx}	& \multicolumn{3}{l}{(\textcolor{blue}{select} 	*}\\
		& 	 			& \multicolumn{3}{l}{\textcolor{blue}{from}		S}\\
		& 	 			& \multicolumn{3}{l}{\textcolor{blue}{where}	B=C)}		
	%
	\\
	\end{tabular}
	}}	
	%
\label{Fig_IntroductionExample_c_table}
}
\bsubfloat[]{%
    %
	\begin{minipage}{45mm}	
	\vspace{5mm}
	\includegraphics[scale=0.4]{figs/Fig_ExampleNotExistsv2}
	\end{minipage}
	%
    \label{Fig_ExampleNotExists}
}
\end{bsubfloatrows}
\caption{Principles 6 \& 7: Queries (a) and (b) are equivalent except if column S.C contains NULL values. 
Thus ignoring NULL values in the database, they are equivalent and their \emph{query intent} can be represented by the same 
\queryvis representation shown in (c)
(example taken and slightly fixed from Fig.~4 in \cite{gatterbauer2011databases}).}
\label{Fig_CompleteExampleAmbiguous}
\end{figure}







\textbf{(7) Output-oriented reading order}:
Similar to a SQL query having an expected order of clauses (e.g.\ SELECT-FROM-WHERE),
also a query visualization benefits from having an expected arrangement and reading order.
Mirroring the design decision from SQL and calculus, we suggest a reading order left-to-right 
that starts with the result of the query (the output table) 
and then adds tables in horizontal layers in decreasing order of their relatedness to the output table (see \autoref{Fig_ExampleNotExists}). 
This suggests an arrangement where the input tables are placed at a horizontal distance from the output table that represents the shortest path join connection to the output table.
Furthermore, the arrangement of the input tables should 
be such as to simplify the reading and understanding of the query 
by following aesthetic heuristics (e.g.\ minimizing the number of line crossings).






\textbf{(8) Logic-based visual transformations}:
Nested negated quantifiers are particularly difficult to understand for users~\cite{DBLP:journals/csur/Reisner81,Reisner1975:HumanFactors}.
Simple visualizations of logical transformation can further help show the query in a more intuitive form.
Take a double negated query such as \autoref{Fig_ExampleVisualizations}:
\begin{align*}
	\{ q(\textit{person}) \mid \;
	& \exists f \in \textit{Frequents}
	[
	q.\textit{person} = f.\textit{person} \wedge
	\neg \exists s \in \textit{Serves} [s.\textit{bar} = f.\textit{bar} \wedge
	\\
	&\neg \exists l \in \textit{Likes} [
	l.\textit{drink} = s.\textit{drink} \wedge 	
	f.\textit{person} = l.\textit{person}	
	] \}	
\end{align*}
The same query can be arguably understood more easily by writing it as
\begin{align*}
	\{ q(\textit{person}) \mid \;
	& \exists f \in \textit{Frequents}
	[
	q.\textit{person} = f.\textit{person} \wedge
	\forall s \in \textit{Serves} [s.\textit{bar} = f.\textit{bar} \rightarrow
	\\
	&\exists l \in \textit{Likes} [
	l.\textit{drink} = s.\textit{drink} \wedge 	
	f.\textit{person} = l.\textit{person}	
	] \}	
\end{align*}



















%
\section{Our Suggestions: \queryvis and \diagrams}

When following the earlier listed design principles, a family of query visualizations naturally emerges.
%
We discuss here two instances that differ in the way they visually encode the \emph{nesting structure between query blocks}:

(1) \queryvis~\cite{DanaparamitaG2011:QueryViz,
gatterbauer2011databases,
DBLP:conf/sigmod/LeventidisZDGJR20}:
This earlier variant from 2011
%
%
%
borrows the idea of a ``default reading order''
from diagrammatic reasoning systems~\cite{DBLP:conf/diagrams/FishH04} 
and uses \emph{arrows} to indicate an implicit reading order between different nesting levels.
Take as example~\autoref{Fig_ExampleNotExists} and notice how the arrows between the relations correspond to the order in which 
they appear in the natural language translation
(``Find persons who FREQUENT some bar that SERVES only drinks they LIKE''). 
Without the arrows, there would be no natural order placed on the existential quantifiers 
and the visualization would be ambiguous.
\queryvis focuses on the non-disjunctive fragment of relational calculus and is guaranteed to represent connected nested queries unambiguously up to nesting level 3.
An interactive online version is available linked from \url{https://queryvis.com}.
	%
	%
	%
	%
	%



(2) \diagrams~\cite{relationalDiagrams}:
This more recent variant indicates the nesting structure of table variables by using \emph{nested negated bounding boxes} instead of arrows.
 %
The nesting of negation boxes is more closely inspired by Peirce's influence beta existential graphs~\cite{peirce:1933,Roberts:1992,Shin:2002}.
%
%
Interestingly, because \diagrams are based on Tuple Relational Calculus (instead of Domain Relational Calculus which is closer to First-Order Logic)
they solve interpretation problems of beta graphs that have been the focus of intense research in the diagrammatic reasoning communities.
The big advantage of this variant is that it has a provably unambiguous interpretation for any nesting depth, 
even for queries with disconnected components,
and for both Boolean and non-Boolean queries.
Furthermore, by adding one additional visual element, \diagrams can be made relationally complete even for non-Boolean queries.
The downside is that these diagrams need more ``ink'' for simple nested queries, 
and logical transformations (design decision 8) cannot be as easily applied anymore.
An alternative to such transformations, however, is using shading for alternating nesting depths
(see e.g.\ \autoref{Fig_ExampleNotExistsRDShaded}).



An interactive online version of \queryvis has been online at \url{https://queryVis.com} since 2011~\cite{DanaparamitaG2011:QueryViz}.
We encourage the reader to try it. 
It currently supports only a limited SQL grammar (see the web page for details). 
Still, this online demo shows that query visualization can have a very lightweight interaction. 
The user does not have to specify anything upfront and can just copy the SQL query and the schema into the two available forms
(notice that the relevant part of the schema could often be inferred from the query). 
	%





	%


	%
	%
	%
	%
	%
	%
	%
	%



	%
	%
	%
	%

	%
	%
	%
	%
	%










\subsection{User study showing users can interpreting queries faster with $\queryvis$}
\label{sec:userstudy}



We designed a user study to test whether our diagrams help users understand SQL queries \emph{in less time} and \emph{with fewer errors}, on average.
The study design and analysis plan was preregistered before we started the experiment and gathered data.  
Details on the study are available 
in \cite{DBLP:conf/sigmod/LeventidisZDGJR20} 
and on OSF at \osfprereg.


\begin{figure}[t]
\centering
\includegraphics[scale=0.6]{figs/study_screenshot_v6.pdf} 
\caption{
	\autoref{sec:userstudy}: 
	Example query from our user study.
    The query is shown in the \emph{Both} condition, in which a participant sees the query in both SQL (left) and 
	our \queryvis diagram (right).
	%
	}
\label{figure:study_screenshot}
\end{figure}


The study is an easily-scalable \emph{within-subjects study}~\cite{seltman2012experimental} 
(i.e., all study participants were exposed to all query interfaces).
%
%
%
The study consisted of 9 multiple-choice questions (MCQs).
 %
Each MCQ asked the participant to choose the best interpretation for a presented query from 4 choices.
Following best practices in MCQ creation~\cite{Zimmaro2010},
we created all 4 choices to read very similar to each other so that a participant with little knowledge of SQL would be incapable of eliminating any of the 4 choices.
Each query was presented to participants in one of 3 conditions: 
(1) seeing a query as SQL alone (``SQL''), 
(2) seeing a query as a logical diagram that was generated from SQL (``QV''), or 
(3) seeing both SQL and \queryvis at the same time (``Both'').
\autoref{figure:study_screenshot} shows the interface for the condition ``Both'' for one of the 9 questions.
Each participant answered \emph{all 9 questions in the same order} but
the condition for each question was 
randomized in a particular way that reduces potential biases in our analysis due to condition ordering effects
following a \emph{Latin square design}~\cite{Ledolter:2007fu,Montgomery:2013wq}.
We then tracked the time needed and errors made by each participant while trying to find the correct interpretation for each query.
%
%
%
Participants had to pass an SQL qualification exam to ensure that they had at least a basic proficiency with SQL.
We made the study available for 3 weeks from Jan 24, 2020--Feb 13, 2020 on Amazon Mechanical Turk (AMT),
during  which we recruited $n = 42$ legitimate participants.


\introparagraph{Results}
There is strong evidence that participants are meaningfully faster (-20\%) using \queryvis than {SQL} 
($p<0.001$). 
There is weak evidence that participants make meaningfully fewer errors (-21\%) using \queryvis than {SQL}
($p=0.15$).
\autoref{figure:differences_no_grouping}
shows the full time and error difference distribution across the 42 participants.








\begin{figure}[t]
\centering
\subfloat[]{
    \includegraphics[scale=0.44]{figs/Fig_time_differences_no_grouping_v2.pdf}
    \label{figure:time_differences_no_grouping}
}
\hspace{25mm}
\subfloat[]{
    \includegraphics[scale=0.44]{figs/Fig_error_differences_no_grouping_v2.pdf}
	\label{figure:error_differences_no_grouping}
}
\caption{\autoref{sec:userstudy}:
Distribution of (QV$-$SQL) time and error differences for each participant on 9 MCQs.
}
\label{figure:differences_no_grouping}
\end{figure}













	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%



	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%



	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%














\section{Related work}
\label{sec:relatedWork}





For decades, SQL has been the main standard for issuing queries over relational databases.
There is a reasonable chance that this widely implemented interface won't be replaced anytime soon. 
Thus we do not propose new ways to write queries, 
but instead explore how to help users \emph{understand existing SQL queries}. 


\introparagraph{Visual Query Languages (VQL)}
Visual methods for expressing queries have been studied
extensively in the database literature~\cite{DBLP:journals/vlc/CatarciCLB97}, 
%
%
and
many commercial database products offer some visual interface for users to write simple SQL queries.
Query Visualization (QV) focuses on the problem of describing and \emph{interpreting a query that has already been written}, which is 
different from the problem of composing a new query (\autoref{QVisnotVQL}).



	%
	%





	%
	%
	%
	%
	%
	%

	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%

    %
    %






	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%



%
%
%



\textbf{Interactive query builders} employ 
visual diagrams that 
%
users can manipulate (most often in order to select tables and attributes)
%
while using \emph{a separate query configurator}
%
(similar to QBE's condition boxes~\cite{DBLP:journals/ibmsj/Zloof77}) 
to specify selection predicates, attributes, and sometimes nesting between queries.
dbForge~\cite{dbforge} is the most advanced and commercially supported tool we found for interactive query building.
Yet it does not show any visual indication for non-equi joins between tables 
and the actual filtering values and aggregation functions can only be added in a separate query configurator.
Moreover, it has limited support for nested queries: 
the inner and outer queries are built separately,
and the diagram for the inner query is \emph{presented separately and disjointly} 
from the diagram for the outer query.
Thus  \emph{no visual depiction of correlated subqueries is possible}.
%
Other graphical SQL editors like SQL Server Management Studio (SSMS)~\cite{ssms}, Active Query Builder~\cite{activequerybuilder}, QueryScope from SQLdep~\cite{queryscope}, MS Access \cite{msAccess}, and
PostgreSQL's pgAdmin3~\cite{pgadmin} lack in even more aspects of visual query representations: 
most do not allow nested queries, 
none has a single visual element for the logical quantifiers 
\texttt{NOT} \texttt{EXISTS} or \texttt{FOR} \texttt{ALL},
and all require specifying details of the query in SQL or across several tabbed views 
\emph{separate from a visual diagram}.
%
%
%
%
%
%
DataPlay~\cite{DBLP:conf/uist/AbouziedHS12} 
allows a user to specify their query by interactively modifying a \emph{query tree with quantifiers}
and observing changes in the matching/non-matching data.
%
%
%
%
%
%
	%
	%
	%
	%
	%
	%
	%
	%
%
Gestural query specification~\cite{10.14778/2732240.2732247}
allows a user to query databases using a series of gestures on a touchscreen.
In short, current graphical SQL editors \emph{do not provide a single encompassing visualization of a query}.
%
%
%
%
Thus they could not (even in theory) transform a complicated SQL query
into a single visual representation, which is the focus of query visualization.
%
%

 %





	%
	%

	%
	%
	%

	%
	%


	%
	%

	%
	%
	%
	%
	%
	%
	%

	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%

	%
	%

	%
	%
	%
	%
	%
	%

%
%
%
%







\textbf{Query visualizations}
%
%
%
%
attempt to create succinct visual representations of existing queries.
%
%
This explicit reverse functionality for SQL has not drawn as much attention as visual query builders,
and there are only a handful of other systems we are aware of~\cite{gatterbauer:diagrams:tutorial:2022}.
%
%
Visual SQL~\cite{DBLP:conf/er/JaakkolaT03} is 
a visual query language that also support query visualization. 
With its focus on query specification, it maintains the one-to-one correspondence to SQL,
and syntactic variants of the same query lead to different representations (\autoref{Fig_CompleteExampleAmbiguous}).
SQLVis~\cite{DBLP:conf/vl/MiedemaF21} shares motivation with \queryvis. 
Similar to Visual SQL, it places a stronger focus on the actual syntax of a SQL query 
and syntactic variants like nested EXISTS queries change the visualization.
%
%
%
%
%
Snowflake join~\cite{snowflakejoin} is an open source project that visualizes join queries with optional grouping.
It does not have any consistent and unambiguous notation for nested queries.
%
GraphSQL~\cite{DBLP:conf/dexaw/CerulloP07} uses visual metaphors that are different from typical relational schema notations 
%
%
and visualizations, even simple conjunctive queries can look unfamiliar.
%
The Query Graph Model (QGM) developed for Starburst~\cite{DBLP:conf/sigmod/HaasFLP89}
helps users understand query plans, not query intent (\autoref{sec:queryplans}).
%
StreamTrace \cite{DBLP:conf/chi/BattleFDBCG16}
focuses on visualizing temporal queries
%
with
	 %
	%
workflow diagrams and a timeline.
It is an example of visualizations for spatio-temporal domains and not the logic behind general relational queries.


	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%





	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%

	%
	%
	%
	%
	%
	%
	%
	%
	%
	%





	%






	%
	%
	%



	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%
	%






%
%
%
%
%
%
%










\section{Various Challenges} 


A vision paper that some of us wrote in 2011 declared that ``Databases will visualize queries too''~\cite{gatterbauer2011databases}.
This has not yet widely happened.
Why so? Is it just a matter of time?  Or is it that we are missing something profound and Queries Visualizations (QV) will go the same route as Visual Query Languages (VQL):
intuitively attractive, but practically not as useful?
%
Instead, perhaps the foundations have been laid, yet there are still problems to be solved
to make that vision practical.
Here is a partial list of several such challenges:

%



\textbf{(1) Extensions}:
Expressing logical disjunction in diagrams is inherently more complicated than conjunction~\cite{Shin:2002}.
And while relational algebra, relational calculus, and Datalog all use set semantics, SQL uses bag semantics.
What are \emph{appropriate visual metaphors} for 
general disjunctions 
and non-logical constructs, such as 
groupings, aggregates, arithmetic predicates, bag semantics, outer joins, null values, and recursion?\footnote{The online \queryvis interface at \url{https://queryVis.com} has been quietly supporting limited forms of aggregates already since 2016.}



\textbf{(2) Relational patterns}:
Something not well understood or even formalized today is the vague concept of ``relational query patterns.''
What are query patterns?
	%
	%
	%
	%
We posit that identifying patterns in queries may have several advantages, 
akin to how formalizing best practices in software design patterns has aided software engineers \cite{Gamma:1995ys}.
General and reusable query patterns could assist in teaching students how to write complicated queries.
Queries written using common patterns could then potentially be easier to interpret quickly.
What is \emph{a rigorous semantic definition of relational query patterns}?
See \cite{relationalDiagrams} for first steps in that direction.



\textbf{(3) Measures of visual conciseness}: 
We listed minimal visual complexity as guiding principle. 
When comparing two languages one could likely develop metrics such as amount of ink used.
However, what is the ultimately right measure for quantifying visual complexity for a human user?
	%
Visual complexity also needs to take into account prior familiar notions (like UML) to a target audience.






\textbf{(4) Automatic layout algorithms}:
The online \queryvis demo uses a layered arrangement of tables that guarantees that any join conditions
are either between two adjacent layers or within the same layer.
It uses the standard Graphviz library for arranging the tables and their attributes~\cite{Ellson03graphvizand}.
However, existing graph layout algorithms are not suited for complicated layered graphs with nested hierarchies.
What are new outline algorithms that can optimize for existing visual metrics (such as minimum line overlap) 
and define novel metrics that capture visual homogeneity?
A possible route is 
encoding existing aesthetic heuristics (such as those in \cite[Table 1]{DBLP:conf/cae/BennettRSG07})
or novel ones
in quantitative metrics, and then
defining the layout problem as Integer Linear Program (ILP). 
A recent proposal that uses this route is STRATISFIMAL LAYOUT~\cite{DBLP:journals/tvcg/BartolomeoRGD22}.







\textbf{(5) Interactive diagrams}:
As already implied by \autoref{Fig_KevinBacon},
\autoref{Fig_TheVision}, 
\autoref{Fig_SpeechAssistant},and
\autoref{fig:beerquery},
the interaction between textual query and query visualization could be more involved beyond a simple one-way translation.
Interactive mouse-over can show correspondences. 
%
An interactive auto-complete feature could suggest possible query templates. 
And a user could be allowed to manipulate an existing template of a query, which then gets reflected in the text
(but notice that this last point would defeat the original idea to keep the visualization lightweight and as easy add-on to an existing query composition workflow).
What is the optimal end-to-end integration of visualization and text or alternative input forms
(recall \autoref{Fig_SpeechAssistant} and \autoref{Fig_TheVision})?


	%


\textbf{(6) Combinations with other modalities}:
We mentioned in \autoref{section:alternatives} alternative ways to help users understand their queries.
Such alternative modalities could possibly be combined with visualizations.
For example, Natural Language translations could possibly benefit from a graphical representation of a query.
Parts of a query could be replaced with an automatically created text and expanded with a click to the full pattern.
Query visualizations could be enhanced with example database instances, or operator-by-operator translations.
The query visualizations could be modified to display how individual records fit or don’t fit the query. 
This could again be done with interactive mouseover or choice from a menu.



\textbf{(7) User studies}: 
We believe that preregistered, within-subjects studies with multiple-choice questions in Latin square design studies, 
where the correctness of a user's answer can be determined automatically,
are the way to go to for easily scalable quantitative comparison between different interfaces. 
In our user study, users needed to pass a SQL qualifying exam and then started the test only after minimum exposure to \queryvis. 
One could only imagine the improvement after the users had chance to become more familiar with the visual language over an extended period of time.
 %
For such a longitudinal study that possibly instruments across control groups there is one big open challenge:
How to parameterize SQL queries and questions in the spirit of Gradiance
\cite{gradiance}
such that the same subjects can take the same test repeatedly?
Such new user study paradigms would allow us 
to observe the improvement in speed and accuracy over an extended period of time.


%

%



%
%
%
%
%
%
%
%
%
%






\textbf{(8) Declarative programming}:
Logical query interfaces have shown success also beyond relational data.
Examples include Datalog for networks
\cite{DBLP:conf/sigmod/HuangGL11,DBLP:journals/cacm/LooCGGHMRRS09,DBLP:conf/sosp/LooCHMRS05}
and Inductive Logic Programming~\cite{SchmidMuggleton:2017}. 
Such programs represent an explicit symbolic structure that can be inspected and understood, and the implied logic visualized.



	%
	%













\section{Conclusions and Future Work} 
\label{sec:conclusions_and_future_work}

We discussed the potential of query visualizations for a future, advanced user-query interaction
that visualizes relational patterns of a query with diagrams.
We delineated query visualization from visual query languages,
discussed a few principles for designing intuitive visual diagrams,
and gave two variants of a family of query visualizations.
Future work needs to  extend visual formalisms for the full relational model and beyond,
find algorithms for automatic arrangement of diagrams,
study novel and more interactive user interfaces 
with query visualizations being just one component, 
create more easily verifiable, large-scale user studies,
and find ways to apply logical representations to other logic-based languages such as Inductive Logic Programming.





\subsection*{Acknowledgements} 

This research is supported in part by NSF awards IIS-1762268, IIS-1956096, and IIS-2145382.
WG would also like to thank \href{https://www.linkedin.com/in/danaparamita/}{Jonathan Danaparamita} 
who created the original interactive QueryVis demo that has been online at 
\url{https://queryvis.com/} since 2011 and
without whom there would have been no \queryvis. 







\bibliographystyle{abbrv}
%

\begin{thebibliography}{100}

\bibitem{DBLP:conf/uist/AbouziedHS12}
A.~Abouzied, J.~M. Hellerstein, and A.~Silberschatz.
\newblock Dataplay: interactive tweaking and example-driven correction of
  graphical database queries.
\newblock In {\em Proceedings of the 25th annual ACM symposium on User
  interface software and technology ({UIST})}, pages 207--218, 2012.
\newblock \url{https://doi.org/10.1145/2380116.2380144}.

\bibitem{activequerybuilder}
{Active Query Builder}.
\newblock \url{https://www.activequerybuilder.com/}, 2019.

\bibitem{Ahmed2015}
T.~M. Ahmed, W.~Shang, and A.~E. Hassan.
\newblock An empirical study of the copy and paste behavior during development.
\newblock In {\em 2015 IEEE/ACM 12th Working Conference on Mining Software
  Repositories}, pages 99--110, 2015.
\newblock \url{https://doi.org/10.1109/MSR.2015.17}.

\bibitem{QueRIERecommendations:2010}
J.~Akbarnejad, G.~Chatzopoulou, M.~Eirinaki, S.~Koshy, S.~Mittal, D.~On,
  N.~Polyzotis, and J.~S.~V. Varman.
\newblock {SQL} {QueRIE} recommendations.
\newblock {\em PVLDB}, 3(1):1597--1600, 2010.
\newblock \url{https://doi.org/10.1145/2839509.2844640}.

\bibitem{ARZAMASOVA2021101646}
N.~Arzamasova and K.~B{\"o}hm.
\newblock Scalable and data-aware sql query recommendations.
\newblock {\em Information Systems}, 96:101646, 2021.
\newblock \url{https://doi.org/10.1016/j.is.2020.101646}.

\bibitem{DBLP:journals/tvcg/BartolomeoRGD22}
S.~D. Bartolomeo, M.~Riedewald, W.~Gatterbauer, and C.~Dunne.
\newblock {STRATISFIMAL} {LAYOUT:} {A} modular optimization model for laying
  out layered node-link network visualizations.
\newblock {\em {IEEE} Transactions on Visualization and Computer Graphics},
  28(1):324--334, 2022.
\newblock \url{https://doi.org/10.1109/TVCG.2021.3114756},
  \url{https://visdunneright.github.io/stratisfimal/}.

\bibitem{10.1145/3503490}
L.~Battle.
\newblock Analyzing online programming communities to enhance visualization
  languages.
\newblock {\em Interactions}, 29(1):27--29, jan 2022.
\newblock \url{https://doi.org/10.1145/3503490}.

\bibitem{DBLP:conf/chi/BattleFDBCG16}
L.~Battle, D.~Fisher, R.~DeLine, M.~Barnett, B.~Chandramouli, and J.~Goldstein.
\newblock Making sense of temporal queries with interactive visualization.
\newblock In {\em Proceedings of the 2016 CHI Conference on Human Factors in
  Computing Systems}, pages 5433--5443, 2016.
\newblock \url{https://doi.org/10.1145/2858036.2858408}.

\bibitem{DBLP:conf/cae/BennettRSG07}
C.~Bennett, J.~Ryall, L.~Spalteholz, and A.~Gooch.
\newblock The aesthetics of graph visualization.
\newblock In {\em 3rd International Symposium on Computational Aesthetics in
  Graphics, Visualization, and Imaging (CompAesth)}, pages 57--64. Eurographics
  Association, 2007.
\newblock \url{https://doi.org/10.2312/COMPAESTH/COMPAESTH07/057-064}.

\bibitem{Brandt2009}
J.~Brandt, P.~J. Guo, J.~Lewenstein, M.~Dontcheva, and S.~R. Klemmer.
\newblock Writing code to prototype, ideate, and discover.
\newblock {\em IEEE Software}, 26(5):18--24, 2009.
\newblock \url{https://doi.org/10.1109/MS.2009.147}.

\bibitem{DBLP:reference/db/Catarci18a}
T.~Catarci.
\newblock Visual query language.
\newblock In {\em Encyclopedia of Database Systems, Second Edition}. Springer,
  2018.
\newblock \url{https://doi.org/10.1007/978-1-4614-8265-9\_448}.

\bibitem{DBLP:journals/vlc/CatarciCLB97}
T.~Catarci, M.~F. Costabile, S.~Levialdi, and C.~Batini.
\newblock Visual query systems for databases: A survey.
\newblock {\em Journal of Visual Languages and Computing}, 8(2):215--260, 1997.
\newblock \url{https://doi.org/10.1006/jvlc.1997.0037}.

\bibitem{DBLP:conf/dexaw/CerulloP07}
C.~Cerullo and M.~Porta.
\newblock A system for database visual querying and query visualization:
  Complementing text and graphics to increase expressiveness.
\newblock In {\em International Workshop on Database and Expert Systems
  Applications (DEXA)}, pages 109--113. {IEEE}, 2007.
\newblock \url{https://doi.org/10.1109/DEXA.2007.91}.

\bibitem{ChanUserDatabaseInterface:1993}
H.~C. Chan, K.~K. Wei, and K.~L. Siau.
\newblock User-database interface: The effect of abstraction levels on query
  performance.
\newblock {\em MIS Quarterly}, 17(4):441--464, 1993.
\newblock \url{https://doi.org/10.2307/249587}.

\bibitem{DBLP:journals/vldb/ChandraCKRS015}
B.~Chandra, B.~Chawda, B.~Kar, K.~V.~M. Reddy, S.~Shah, and S.~Sudarshan.
\newblock Data generation for testing and grading {SQL} queries.
\newblock {\em {VLDB} J.}, 24(6):731--755, 2015.
\newblock \url{https://doi.org/10.1007/s00778-015-0395-0}.

\bibitem{DBLP:conf/ssdbm/ChatzopoulouEP09}
G.~Chatzopoulou, M.~Eirinaki, and N.~Polyzotis.
\newblock Query recommendations for interactive database exploration.
\newblock In {\em International Conference on Scientific and Statistical
  Database Management (SSDBM)}, volume 5566 of {\em LNCS}, pages 3--18.
  Springer, 2009.
\newblock \url{https://doi.org/10.1007/978-3-642-02279-1\_2}.

\bibitem{Chen:2006vn}
C.~Chen.
\newblock {\em Information visualization: beyond the horizon}.
\newblock Springer, New York, 2nd edition, 2006.
\newblock \url{https://doi.org/10.1007/1-84628-579-8}.

\bibitem{DBLP:conf/cidr/ChuWWC17}
S.~Chu, C.~Wang, K.~Weitz, and A.~Cheung.
\newblock Cosette: An automated prover for {SQL}.
\newblock In {\em 8th biennial Conference on Innovative Data Systems Research
  ({CIDR})}, 2017.
\newblock \url{http://cidrdb.org/cidr2017/papers/p51-chu-cidr17.pdf}.

\bibitem{Ciborowska2018}
A.~Ciborowska, N.~A. Kraft, and K.~Damevski.
\newblock Detecting and characterizing developer behavior following
  opportunistic reuse of code snippets from the {Web}.
\newblock In {\em Proceedings of the 15th International Conference on Mining
  Software Repositories (MSR)}, pages 94--97. ACM, 2018.
\newblock \url{https://doi.org/10.1145/3196398.3196467}.

\bibitem{DBLP:journals/iam/ClarkW94}
G.~J. Clark and C.~T. Wu.
\newblock {DFQL}: Dataflow query language for relational databases.
\newblock {\em Information \& Management}, 27(1):1--15, 1994.
\newblock \url{https://doi.org/10.1016/0378-7206(94)90098-1}.

\bibitem{cover:thomas:2006}
T.~M. Cover and J.~A. Thomas.
\newblock {\em Elements of Information Theory}.
\newblock Wiley-Interscience, USA, 2nd edition, 2006.
\newblock \url{https://doi.org/10.1002/047174882X}.

\bibitem{DanaparamitaG2011:QueryViz}
J.~Danaparamita and W.~Gatterbauer.
\newblock Queryviz: Helping users understand {SQL} queries and their patterns.
\newblock In {\em Proceedings of the 14th International Conference on Extending
  Database Technology ({EDBT})}, pages 558--561. ACM, 2011.
\newblock \url{https://doi.org/10.1145/1951365.1951440},
  \url{https://queryvis.com/}.

\bibitem{dbforge}
{dbForge}.
\newblock \url{https://www.devart.com/dbforge/mysql/querybuilder/}, 2019.

\bibitem{Eirinaki:QueRie:2014}
M.~Eirinaki, S.~Abraham, N.~Polyzotis, and N.~Shaikh.
\newblock {QueRIE}: Collaborative database exploration.
\newblock {\em IEEE Transactions on Knowledge and Data Engineering (TKDE)},
  26(7):1778--1790, 2014.
\newblock \url{https://doi.org/10.1109/TKDE.2013.79}.

\bibitem{Ellson03graphvizand}
J.~Ellson, E.~Gansner, E.~Koutsofios, S.~North, and G.~Woodhull.
\newblock {\em Graphviz and Dynagraph -- Static and Dynamic Graph Drawing
  Tools}, pages 127--148.
\newblock Springer, 2004.
\newblock \url{https://doi.org/10.1007/978-3-642-18638-7_6}.

\bibitem{DBLP:conf/icde/FanLZ11}
J.~Fan, G.~Li, and L.~Zhou.
\newblock Interactive {SQL} query suggestion: Making databases user-friendly.
\newblock In {\em 27th International Conference on Data Engineering (ICDE)},
  pages 351--362, 2011.
\newblock \url{https://doi.org/10.1109/ICDE.2011.5767843}.

\bibitem{DBLP:conf/diagrams/FishH04}
A.~Fish and J.~Howse.
\newblock Towards a default reading for constraint diagrams.
\newblock In {\em International Conference on Theory and Application of
  Diagrams ({DIAGRAMS})}, pages 51--65. Springer, 2004.
\newblock \url{https://doi.org/10.1007/978-3-540-25931-2\_8}.

\bibitem{folwer:UMLdistilled:2003}
M.~Fowler.
\newblock {\em UML Distilled: A Brief Guide to the Standard Object Modeling
  Language}.
\newblock Addison-Wesley Longman, 3rd edition, 2003.
\newblock \url{https://dl.acm.org/doi/10.5555/861282}.

\bibitem{Gamma:1995ys}
E.~Gamma.
\newblock {\em Design patterns: elements of reusable object-oriented software}.
\newblock Addison-Wesley, 1995.
\newblock \url{https://dl.acm.org/doi/book/10.5555/186897}.

\bibitem{DBLP:conf/chi/GathaniLB20}
S.~Gathani, P.~Lim, and L.~Battle.
\newblock Debugging database queries: {A} survey of tools, techniques, and
  users.
\newblock In {\em Conference on Human Factors in Computing Systems ({CHI})},
  pages 1--16, 2020.
\newblock \url{https://doi.org/10.1145/3313831.3376485}.

\bibitem{gatterbauer2011databases}
W.~Gatterbauer.
\newblock Databases will visualize queries too.
\newblock {\em PVLDB}, 4(12):1498--1501, 2011.
\newblock \url{https://doi.org/10.14778/3402755.3402805},
  \url{http://www.youtube.com/watch?v=kVFnQRGAQls}.

\bibitem{gatterbauer:diagrams:tutorial:2022}
W.~Gatterbauer.
\newblock Interpreting and understanding relational database queries using
  diagrams.
\newblock International Conference on Theory and Application of Diagrams
  ({DIAGRAMS}) -- Tutorials, 2022.
\newblock
  \url{http://www.diagrams-conference.org/2022/index.php/program/tutorials/}.

\bibitem{relationalDiagrams}
W.~Gatterbauer, C.~Dunne, and M.~Riedewald.
\newblock Relational diagrams: a pattern-preserving diagrammatic representation
  of non-disjunctive relational queries.
\newblock {\em Arxiv preprint arXiv:2203.07284}, 2022.
\newblock \url{https://arxiv.org/abs/2203.07284}.

\bibitem{DBLP:conf/inlg/GehrmannDER18}
S.~Gehrmann, F.~Z. Dai, H.~Elder, and A.~M. Rush.
\newblock End-to-end content and plan selection for data-to-text generation.
\newblock In {\em International Conference on Natural Language Generation
  (INLG)}, pages 46--56. ACM, 2018.
\newblock \url{https://doi.org/10.18653/v1/w18-6505}.

\bibitem{gradiance}
{Gradiance}.
\newblock \url{https://www.gradiance.com/services}, 2022.

\bibitem{GREENE1990303}
S.~L. Greene, S.~J. Devlin, P.~E. Cannata, and L.~M. Gomez.
\newblock No {IFs}, {ANDs}, or {ORs}: A study of database querying.
\newblock {\em International Journal of Man-Machine Studies}, 32(3):303--326,
  1990.
\newblock \url{https://doi.org/10.1016/S0020-7373(08)80005-3}.

\bibitem{GrustKRS2011:SQLdebugging}
T.~Grust, F.~Kliebhan, J.~Rittinger, and T.~Schreiber.
\newblock True language-level {SQL} debugging.
\newblock In {\em Proceedings of the 14th International Conference on Extending
  Database Technology ({EDBT})}, pages 562--565, 2011.
\newblock \url{https://doi.org/10.1145/1951365.1951441}.

\bibitem{DBLP:journals/tods/GrustR13}
T.~Grust and J.~Rittinger.
\newblock Observing {SQL} queries in their natural habitat.
\newblock {\em ACM Transactions on Database Systems (TODS)}, 38(1):3, 2013.
\newblock \url{https://doi.org/10.1145/2445583.2445586}.

\bibitem{DBLP:journals/sigmod/GuagliardoL17}
P.~Guagliardo and L.~Libkin.
\newblock Correctness of {SQL} queries on databases with nulls.
\newblock {\em {SIGMOD} Record}, 46(3):5--16, 2017.
\newblock \url{https://doi.org/10.1145/3156655.3156657}.

\bibitem{DBLP:conf/sigmod/HaasFLP89}
L.~M. Haas, J.~C. Freytag, G.~M. Lohman, and H.~Pirahesh.
\newblock Extensible query processing in {S}tarburst.
\newblock {\em SIGMOD Record}, 18(2):377--388, 1989.
\newblock \url{https://doi.org/10.1145/67544.66962}.

\bibitem{DBLP:journals/bsl/HalpernHIKVV01}
J.~Y. Halpern, R.~Harper, N.~Immerman, P.~G. Kolaitis, M.~Y. Vardi, and
  V.~Vianu.
\newblock On the unusual effectiveness of logic in computer science.
\newblock {\em Bulletin of Symbolic Logic}, 7(2):213--236, 2001.
\newblock \url{https://doi.org/10.2307/2687775}.

\bibitem{Harel:Nonprocedural:1985}
E.~C. Harel and E.~R. McLean.
\newblock The effects of using a nonprocedural computer language on programmer
  productivity.
\newblock {\em MIS Quarterly}, 9(2):109--120, jun 1985.
\newblock \url{https://doi.org/10.2307/249112}.

\bibitem{DBLP:journals/pvldb/Haritsa10}
J.~R. Haritsa.
\newblock The {Picasso} database query optimizer visualizer.
\newblock {\em PVLDB}, 3(2):1517--1520, 2010.
\newblock \url{https://doi.org/10.14778/1920841.1921027}.

\bibitem{HoweC2010:SQLshare}
B.~Howe and G.~Cole.
\newblock {SQL} is dead; long live {SQL}: Lightweight query services for ad hoc
  research data.
\newblock In {\em 4th Microsoft eScience Workshop}, 2010.
\newblock
  \url{https://homes.cs.washington.edu/~billhowe/projects/2014/03/22/SQLShare.html}.

\bibitem{DBLP:conf/iccs/Howse08}
J.~Howse.
\newblock Diagrammatic reasoning systems.
\newblock In {\em International Conference on Conceptual Structures (ICCS)},
  volume 5113 of {\em LNCS}, pages 1--20. Springer, 2008.
\newblock \url{https://doi.org/10.1007/978-3-540-70596-3\_1}.

\bibitem{DBLP:conf/sigmod/HuangGL11}
S.~S. Huang, T.~J. Green, and B.~T. Loo.
\newblock Datalog and emerging applications: an interactive tutorial.
\newblock In {\em Proceedings of the {ACM} {SIGMOD} International Conference on
  Management of Data ({SIGMOD})}, pages 1213--1216, 2011.
\newblock \url{https://doi.org/10.1145/1989323.1989456}.

\bibitem{DBLP:conf/nldb/Ioannidis08}
Y.~E. Ioannidis.
\newblock From databases to natural language: The unusual direction.
\newblock In {\em International Conference on Application of Natural Language
  to Information Systems (NLDB)}, volume 5039 of {\em LNCS}, pages 12--16.
  Springer, 2008.
\newblock \url{https://doi.org/10.1007/978-3-540-69858-6\_3}.

\bibitem{DBLP:conf/er/JaakkolaT03}
H.~Jaakkola and B.~Thalheim.
\newblock Visual sql -- high-quality er-based query treatment.
\newblock In {\em Workshops @ International Conference on Conceptual Modeling
  (ER)}, LNCS, pages 129--139. Springer, 2003.
\newblock \url{https://doi.org/10.1007/978-3-540-39597-3\_13}.

\bibitem{SQLshare:2016}
S.~Jain, D.~Moritz, D.~Halperin, B.~Howe, and E.~Lazowska.
\newblock {SQLShare}: Results from a multi-year {SQL}-as-a-service experiment.
\newblock In {\em Proceedings of the 2016 International Conference on
  Management of Data ({SIGMOD})}, pages 281--293, 2016.
\newblock \url{https://doi.org/10.1145/2882903.2882957}.

\bibitem{Jarke:NL:1985}
M.~Jarke, J.~Tuner, E.~Stohr, Y.~Vassiliou, N.~White, and K.~Michielsen.
\newblock A field evaluation of natural language for data retrieval.
\newblock {\em IEEE Transactions on Software Engineering}, SE-11(1):97--114,
  1985.
\newblock \url{https://doi.org/10.1109/TSE.1985.231847}.

\bibitem{FrameworkForChoosingQueryLanguages:1985}
M.~Jarke and Y.~Vassiliou.
\newblock A framework for choosing a database query language.
\newblock {\em ACM Computing Surveys}, 17(3):313--340, 1985.
\newblock \url{https://doi.org/10.1145/5505.5506}.

\bibitem{DBLP:conf/kbse/KhalekELK08}
S.~A. Khalek, B.~Elkarablieh, Y.~O. Laleye, and S.~Khurshid.
\newblock Query-aware test generation using a relational constraint solver.
\newblock In {\em 23rd {IEEE/ACM} International Conference on Automated
  Software Engineering {(ASE})}, pages 238--247, 2008.
\newblock \url{https://doi.org/10.1109/ASE.2008.34}.

\bibitem{DBLP:journals/pvldb/KhanX0H17}
M.~A. Khan, L.~Xu, A.~Nandi, and J.~M. Hellerstein.
\newblock Data tweening: Incremental visualization of data transforms.
\newblock {\em {PVLDB}}, 10(6):661--672, 2017.
\newblock \url{https://doi.org/10.14778/3055330.3055333}.

\bibitem{DBLP:conf/cidr/KhoussainovaBGKS09}
N.~Khoussainova, M.~Balazinska, W.~Gatterbauer, Y.~Kwon, and D.~Suciu.
\newblock A case for a collaborative query management system.
\newblock In {\em 4th biennial Conference on Innovative Data Systems Research
  ({CIDR})}, 2009.
\newblock \url{https://database.cs.wisc.edu/cidr/cidr2009/Paper\_94.pdf}.

\bibitem{KhoussainovaKBS:2011}
N.~Khoussainova, Y.~Kwon, M.~Balazinska, and D.~Suciu.
\newblock {SnipSuggest}: A context-aware {SQL}-autocomplete system.
\newblock {\em PVLDB}, 4(1):22--33, 2010.
\newblock \url{https://doi.org/10.14778/1880172.1880175}.

\bibitem{DBLP:conf/icde/KoutrikaSI10}
G.~Koutrika, A.~Simitsis, and Y.~E. Ioannidis.
\newblock Explaining structured queries in natural language.
\newblock In {\em International Conference on Data Engineering ({ICDE})}, pages
  333--344. {IEEE}, 2010.
\newblock \url{http://doi.org/10.1109/ICDE.2010.5447824}.

\bibitem{latex}
LaTeX.
\newblock \url{https://en.wikipedia.org/wiki/LaTeX}, 2022.

\bibitem{Latoza2006}
T.~D. LaToza, G.~Venolia, and R.~DeLine.
\newblock Maintaining mental models: A study of developer work habits.
\newblock In {\em Proceedings of the 28th International Conference on Software
  Engineering (ICSE)}, pages 492--501, 2006.
\newblock \url{https://doi.org/10.1145/1134285.1134355}.

\bibitem{Ledolter:2007fu}
J.~Ledolter and A.~J. Swersey.
\newblock {\em Testing 1-2-3: experimental design with applications in
  marketing and service operations}.
\newblock Stanford Business Books, 2007.
\newblock \url{https://www.sup.org/books/title/?id=4513}.

\bibitem{LEGGETT1984493}
J.~Leggett and G.~Williams.
\newblock An empirical investigation of voice as an input modality for computer
  programming.
\newblock {\em International Journal of Man-Machine Studies}, 21(6):493--520,
  1984.
\newblock \url{https://doi.org/10.1016/S0020-7373(84)80057-7}.

\bibitem{DBLP:conf/sigmod/LeventidisZDGJR20}
A.~Leventidis, J.~Zhang, C.~Dunne, W.~Gatterbauer, H.~V. Jagadish, and
  M.~Riedewald.
\newblock Queryvis: Logic-based diagrams help users understand complicated
  {SQL} queries faster.
\newblock In {\em Proceedings of the 2020 ACM SIGMOD International Conference
  on Management of Data}, pages 2303--2318, 2020.
\newblock \url{https://doi.org/10.1145/3318464.3389767}, Full version:
  \url{https://osf.io/btszh/}.

\bibitem{LiFWWF2011:DBease}
G.~Li, J.~Fan, H.~Wu, J.~Wang, and J.~Feng.
\newblock {DBease}: Making databases user-friendly and easily accessible.
\newblock In {\em 5th biennial Conference on Innovative Data Systems Research
  (CIDR)}, pages 45--56, 2011.
\newblock \url{http://cidrdb.org/cidr2011/Papers/CIDR11\_Paper6.pdf}.

\bibitem{DBLP:journals/cacm/LooCGGHMRRS09}
B.~T. Loo, T.~Condie, M.~N. Garofalakis, D.~E. Gay, J.~M. Hellerstein,
  P.~Maniatis, R.~Ramakrishnan, T.~Roscoe, and I.~Stoica.
\newblock Declarative networking.
\newblock {\em Communications of the ACM}, 52(11):87--95, 2009.
\newblock \url{https://doi.org/10.1145/1592761.1592785}.

\bibitem{DBLP:conf/sosp/LooCHMRS05}
B.~T. Loo, T.~Condie, J.~M. Hellerstein, P.~Maniatis, T.~Roscoe, and I.~Stoica.
\newblock Implementing declarative overlays.
\newblock In {\em Proceedings of the 20th {ACM} Symposium on Operating Systems
  Principles ({SOSP})}, pages 75--90, 2005.
\newblock \url{https://doi.org/10.1145/1095810.1095818}.

\bibitem{Marcel:QueryRecommendations:2011}
P.~Marcel and E.~Negre.
\newblock A survey of query recommendation techniques for datawarehouse
  exploration.
\newblock In {\em 7th Conference on Data Warehousing and On-Line Analysis
  (EDA)}, 2011.
\newblock \url{http://eda2011.cemagref.fr/}.

\bibitem{DBLP:conf/mud/MeliouGMS10}
A.~Meliou, W.~Gatterbauer, K.~F. Moore, and D.~Suciu.
\newblock {WHY} so? or {WHY} no? {F}unctional causality for explaining query
  answers.
\newblock In {\em Proceedings of the 4th International {VLDB} workshop on
  Management of Uncertain Data {(MUD})}, pages 3--17, 2010.
\newblock \url{http://arxiv.org/abs/0912.5340}.

\bibitem{MRJ:ExplainingWrongQueries:2019}
Z.~Miao, S.~Roy, and J.~Yang.
\newblock Explaining wrong queries using small examples.
\newblock In {\em Proceedings of the 2019 International Conference on
  Management of Data ({SIGMOD})}, pages 503--520, 2019.
\newblock \url{https://doi.org/10.1145/3299869.3319866}.

\bibitem{msAccess}
{Microsoft Access}.
\newblock \url{https://products.office.com/en-us/access}, 2019.

\bibitem{DBLP:conf/vl/MiedemaF21}
D.~Miedema and G.~Fletcher.
\newblock {SQLVis}: Visual query representations for supporting {SQL} learners.
\newblock In {\em Symposium on Visual Languages and Human-Centric Computing
  ({VL/HCC})}, pages 1--9. {IEEE}, 2021.
\newblock \url{https://doi.org/10.1109/VL/HCC51201.2021.9576431}.

\bibitem{Milo:REACT:2016}
T.~Milo and A.~Somech.
\newblock React: Context-sensitive recommendations for data analysis.
\newblock In {\em Proceedings of the 2016 International Conference on
  Management of Data ({SIGMOD})}, pages 2137--2140, 2016.
\newblock \url{https://doi.org/10.1145/2882903.2899392}.

\bibitem{Montgomery:2013wq}
D.~C. Montgomery.
\newblock {\em Design and analysis of experiments}.
\newblock John Wiley \& Sons, Inc., 8th edition, 2013.
\newblock \url{https://dl.acm.org/doi/book/10.5555/1206386}.

\bibitem{MYERS199097}
B.~A. Myers.
\newblock Taxonomies of visual programming and program visualization.
\newblock {\em Journal of Visual Languages \& Computing}, 1(1):97 -- 123, 1990.
\newblock \url{https://doi.org/10.1016/S1045-926X(05)80036-9}.

\bibitem{10.14778/2732240.2732247}
A.~Nandi, L.~Jiang, and M.~Mandel.
\newblock Gestural query specification.
\newblock {\em {PVLDB}}, 7(4):289--300, 2013.
\newblock \url{https://doi.org/10.14778/2732240.2732247}.

\bibitem{DBLP:conf/sigmod/OlstonCS09}
C.~Olston, S.~Chopra, and U.~Srivastava.
\newblock Generating example data for dataflow programs.
\newblock In {\em Proceedings of the 35th SIGMOD international conference on
  Management of data}, pages 245--256, 2009.
\newblock \url{https://doi.org/10.1145/1559845.1559873}.

\bibitem{peirce:1933}
C.~S. Peirce.
\newblock Charles {H}artshorne and {P}aul {W}eiss ({E}ditors). {C}ollected
  papers of {C}harles {S}anders {P}eirce. vol. 4.
\newblock {\em The ANNALS of the American Academy of Political and Social
  Science}, 1933.
\newblock \url{https://doi.org/10.1177/000271623417400185}.

\bibitem{pgadmin}
{pgAdmin}.
\newblock \url{https://www.pgadmin.org/}, 2019.

\bibitem{postgres}
{PostgreSQL}.
\newblock \url{https://www.postgresql.org/}, 2022.

\bibitem{queryscope}
{QueryScope}.
\newblock \url{https://sqldep.com/}, 2019.

\bibitem{DBLP:journals/csur/Reisner81}
P.~Reisner.
\newblock Human factors studies of database query languages: A survey and
  assessment.
\newblock {\em ACM Computing Surveys}, 13(1):13--31, 1981.
\newblock \url{https://doi.org/10.1145/356835.356837}.

\bibitem{Reisner1975:HumanFactors}
P.~Reisner, R.~F. Boyce, and D.~D. Chamberlin.
\newblock Human factors evaluation of two data base query languages: Square and
  sequel.
\newblock In {\em Proceedings of the May 19-22, 1975, national computer
  conference and exposition (AFIPS)}, pages 447--452. ACM, 1975.
\newblock \url{https:/doi.org/10.1145/1499949.1500036}.

\bibitem{DBLP:journals/vlc/Reiss07}
S.~P. Reiss.
\newblock Visual representations of executing programs.
\newblock {\em Journal of Visual Languages \& Computing}, 18(2):126--148, 2007.
\newblock \url{https://doi.org/10.1016/j.jvlc.2007.01.003}.

\bibitem{Roberts:1992}
D.~D. Roberts.
\newblock The existential graphs.
\newblock {\em Computers \& Mathematics with Applications}, 23(6):639--663,
  1992.
\newblock \url{https://doi.org/10.1016/0898-1221(92)90127-4}.

\bibitem{SchmidMuggleton:2017}
U.~Schmid, C.~Zeller, T.~Besold, A.~Tamaddoni-Nezhad, and S.~Muggleton.
\newblock How does predicate invention affect human comprehensibility?
\newblock In {\em International Conference on Inductive Logic Programming
  (ILP)}, volume 10326 of {\em LNCS}, pages 52--67. Springer, 2017.
\newblock \url{https://doi.org/10.1007/978-3-319-63342-8_5}.

\bibitem{seltman2012experimental}
H.~J. Seltman.
\newblock {\em Experimental design and analysis}.
\newblock Carnegie Mellon University, 2012.
\newblock \url{http://www.stat.cmu.edu/~hseltman/309/Book/Book.pdf}.

\bibitem{Shin:2002}
S.-J. Shin.
\newblock {\em The Iconic Logic of Peirce's Graphs}.
\newblock The MIT Press, 2002.
\newblock \url{https://doi.org/10.7551/mitpress/3633.001.0001}.

\bibitem{DBLP:conf/cidr/SimitsisI09}
A.~Simitsis and Y.~E. Ioannidis.
\newblock {DBMSs} should talk back too.
\newblock In {\em 4th biennial Conference on Innovative Data Systems Research
  ({CIDR})}, 2009.
\newblock \url{https://database.cs.wisc.edu/cidr/cidr2009/Paper\_119.pdf}.

\bibitem{SDSS}
{Sloan Digital Sky Survey (SDSS)}, 2022.
\newblock \url{https://www.sdss.org/}.

\bibitem{snowflakejoin}
{Snowflake join}.
\newblock \url{http://revj.sourceforge.net}, 2022.

\bibitem{ssms}
{SQL Server Management Studio}.
\newblock
  \url{https://www.microsoft.com/en-us/sql-server/sql-server-downloads}, 2019.

\bibitem{sqlparse}
{sqlparse}.
\newblock \url{https://pypi.org/project/sqlparse/}, 2022.

\bibitem{tufte2001visual}
E.~R. Tufte.
\newblock {\em The Visual Display of Quantitative Information}.
\newblock Graphics Press, 2nd edition, 2001.
\newblock \url{https://www.edwardtufte.com/tufte/books_vdqi}.

\bibitem{DBLP:conf/lpar/VeanesTH10}
M.~Veanes, N.~Tillmann, and J.~de~Halleux.
\newblock Qex: Symbolic {SQL} query explorer.
\newblock In {\em Proceedings of the 16th international conference on Logic for
  programming, artificial intelligence, and reasoning (LPAR)}, volume 6355 of
  {\em LNCS}, pages 425--446. Springer, 2010.
\newblock \url{https://doi.org/10.1007/978-3-642-17511-4\_24}.

\bibitem{DBLP:conf/sigmod/WangBLJLC21}
W.~Wang, S.~S. Bhowmick, H.~Li, S.~R. Joty, S.~Liu, and P.~Chen.
\newblock Towards enhancing database education: Natural language generation
  meets query execution plans.
\newblock In {\em Proceedings of the 2021 International Conference on
  Management of Data ({SIGMOD})}, pages 1933--1945, 2021.
\newblock \url{https://doi.org/10.1145/3448016.3452822}.

\bibitem{Welty-Stemple:1981}
C.~Welty and D.~W. Stemple.
\newblock Human factors comparison of a procedural and a nonprocedural query
  language.
\newblock {\em ACM Transactions on Database Systems (TODS)}, 6(4):626--649,
  1981.
\newblock \url{https://doi.org/10.1145/319628.319656}.

\bibitem{DBLP:conf/emnlp/XuWWFS18}
K.~Xu, L.~Wu, Z.~Wang, Y.~Feng, and V.~Sheinin.
\newblock {SQL}-to-text generation with graph-to-sequence model.
\newblock In {\em Proceedings of the 2018 Conference on Empirical Methods in
  Natural Language Processing ({EMNLP})}, pages 931--936. ACL, 2018.
\newblock \url{https://doi.org/10.18653/v1/d18-1112}.

\bibitem{Yang2017}
D.~Yang, P.~Martins, V.~Saini, and C.~Lopes.
\newblock Stack overflow in {Github}: Any snippets there?
\newblock In {\em 14th International Conference on Mining Software Repositories
  (MSR)}, pages 280--290, 2017.
\newblock \url{https://doi.org/10.1109/MSR.2017.13}.

\bibitem{scamell:1993}
M.-M. Yen and R.~Scamell.
\newblock A human factors experimental comparison of {SQL} and {QBE}.
\newblock {\em IEEE Transactions on Software Engineering}, 19(4):390--409,
  1993.
\newblock \url{https://doi.org/10.1109/32.223806}.

\bibitem{Zhang:2007zr}
K.~Zhang.
\newblock {\em Visual languages and applications}.
\newblock Springer, New York, 2007.
\newblock \url{https://doi.org/10.1007/978-0-387-68257-0}.

\bibitem{Zimmaro2010}
D.~M. Zimmaro.
\newblock {\em Writing Good Multiple-Choice Exams}.
\newblock Center for Teaching and Learning, UT Austin., 2010.
\newblock
  \url{https://facultyinnovate.utexas.edu/sites/default/files/writing-good-multiple-choice-exams-fic-120116.pdf}.

\bibitem{DBLP:journals/ibmsj/Zloof77}
M.~M. Zloof.
\newblock Query-by-example: A data base language.
\newblock {\em IBM Systems Journal}, 16(4):324--343, 1977.
\newblock \url{https://doi.org/10.1147/sj.164.0324}.

\end{thebibliography}


\end{document}
