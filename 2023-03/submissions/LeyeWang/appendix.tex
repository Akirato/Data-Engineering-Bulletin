%\onecolumn
\appendix
\section{Appendix}

\subsection{Theoretical Proof}

%\subsubsection{Correctness} We first prove that the correctness of our secure leader-board algorithm.
%
%\vspace{+.5em}
%\textbf{Lemma 5.1}. $\sum_{k=1}^{2t+1} r_k(x)\tau_{i_k}(x)$ can be represented as:
%$$h_{i}+a_{i1}x+a_{i2}x^2+...+a_{i2t}x^{2t}$$
%where $h_i=\sum_{k=1}^{2t+1} r_k\tau_i^k$. \cite{tang2011secure}

\textbf{Proof of Lemma 5.1}. It is clear that,
\begin{equation}
	\sum_{k=1}^{2t+1} r_k(0)\tau_{i_k}(0) = \sum_{k=1}^{2t+1} r_k\tau_i^k
\end{equation}
Besides, both $r_k(x)$ and $\tau_{i_k}(x)$ are $t$-degree polynomials, and thus the degree of $\sum_k r_k(x)\tau_{i_k}(x)$ is $2t$.$\qed$

\vspace{+.5em}
%\textbf{Theorem 5.1}. With $t+1$ participants' $h'_i(k)$, we can recover $h_i$.

\noindent \textbf{Proof of Theorem 5.1}. With Lemma 5.1, for $N$ ($=2t+1$) groups, $\gamma(gid(u_j))
=\sum_{k=1}^{2t+1} r_k(gid(u_j)) \tau_{i_k}(gid(u_j))$ (Step 4) is:

\[
\small
\left(\begin{array}{ccccc} 
	1 &    1 & 1^2 & ...  & 1^{2t} \\ 
	1 &    2 & 2^2 & ... & 2^{2t}\\
	... & ... & ... & ...& ...\\
	1 & N & N^2 & ... & N^{2t}\\
\end{array}\right) 
\left(\begin{array}{c} 
	h_i    \\ 
	a_{i1}    \\
	... \\
	a_{i2t} \\
\end{array}\right) 
=
\left(\begin{array}{c} 
	\gamma(1)    \\ 
	\gamma(2)    \\
	... \\
	\gamma(N) \\
\end{array}\right) 
\]
then,
\[
\small
\left(\begin{array}{c} 
	h_i    \\ 
	a_{i1}    \\
	... \\
	a_{i2t} \\
\end{array}\right) 
=
\left(\begin{array}{ccccc} 
	1 &    1 & 1^2 & ...  & 1^{2t} \\ 
	1 &    2 & 2^2 & ... & 2^{2t}\\
	... & ... & ... & ...& ...\\
	1 & N & N^2 & ... & N^{2t}\\
\end{array}\right)^{-1} 
\left(\begin{array}{c} 
	\gamma(1)    \\ 
	\gamma(2)    \\
	... \\
	\gamma(N) \\
\end{array}\right) 
\]
so,
$$h_i=\sum_{g=1}^{N} \lambda(g)\gamma(g)$$

In Step 5, $h_i(g)=\lambda(g)\gamma(g)$ is shared with $(t+1,n)$-SSS to all the participants from every group $g \in [1, 2t+1]$. Hence, according to the additive homomorphism property of SSS \cite{shamir1979share}, we can easily recover $h_i$ by receiving $t+1$ participants'  $h'_i(k) = \sum_{g=1}^{2t+1} h_i(g, k)$.$\qed$

\vspace{+.5em}
%\textbf{Theorem 5.2}. Ranking $h_i$ is equivalent to ranking $\tau_i$.

\noindent \textbf{Proof of Theorem 5.2}. As $\tau_i>0$ and $r_k>0$, $h_i=\sum_k r_k\tau_i^k$ will keep the same ranking as $\tau_i$.$\qed$

%\subsubsection{Robustness to Connection Loss} While mobile users may lose network connections during a crowdsensing campaign, we analyze how our secure ranking algorithm can tolerate connection losses. Without the loss of generalizability, we assume that before Step 2, there is no user connection loss.\footnote{If $u_i$ loses the connection in Step 2 and cannot share $\tau_i^k$ with SSS, then there is no way to rank $u_i$'s position because the server has no $u_i$'s information. So we only consider the users who establish the connections to share $\tau_i^k$ in Step 2 for ranking.}

\vspace{+.5em}
%\textbf{Theorem 5.3}. To finish Step 3-5, there needs at least one user online for each group. Suppose that every user has $p_l$ probability to lose connection and there are totally $n$ users, the success probability $\ge (1-p_l^{\lfloor n/(2t+1) \rfloor})^{2t+1}$.

\noindent \textbf{Proof of Theorem 5.3}. For Step 3 to 5, if there is at least one user in every group, then the process can continue. So the probability of failure incurred by one specific group $g$ is all the users in $g$ losing the connections, i.e., $p^{n_g} \le p_l^{\lfloor n/(2t+1) \rfloor}$ ($n_g$ is the user number in $g$). So for $g$, the probability of at least one user online $\ge 1-p_l^{\lfloor n/(2t+1) \rfloor}$. With $2t+1$ groups, the success probability $\ge (1-p_l^{\lfloor n/(2t+1) \rfloor})^{2t+1}$.$\qed$
%For Step 6 to 8, if at least $t'$ users have connections, then the server can recover $h_i$. Hence, the probability of failure is more than $N-t'$ users losing connections:
%$$p^{N-t'+1}$$

\vspace{+.5em}
%\textbf{Theorem 5.4}. To finish Step 6-8, $\ge t+1$ users need to be online.

\noindent \textbf{Proof of Theorem 5.4}. This is based on the property of $(t+1, n)$-SSS in Step 5.$\qed$


\vspace{+.5em}
%\textbf{Theorem 5.5} If there are no more than $t$ collusive participants, then these participants cannot recover all the other users' $\tau_i$.

\noindent \textbf{Proof of Theorem 5.5}. In Step 2, $\tau_i^k (k=1...2t+1)$ is shared with $(t+1, 2t+1)$-SSS. So, if $t$ participants collude, they can get at most $t\cdot(2t+1)$ equations when $t$ participants are from $t$ groups. However, the number of unknown parameters (including $\tau_i$ and $t$ random coefficients for sharing each $\tau_i^k$) is $t\cdot(2t+1)+1$. Hence, these $t$ collusive participants cannot recover other participants' $\tau_i$.$\qed$

\subsection{Mechanism Extension to Multi-class and Continuous-value Events}



\textbf{Multi-class Events}. For a multi-class event ($m$ classes), we can see it as $m$ binary events, so that our method can be directly applied.

\noindent \textbf{Continuous-value Events}. For continuous-value events, following the literature, we may adopt other proper event confidence and participant trustworthiness updating functions such as CRH \cite{Xu2019EfficientAP,Zheng2020PrivacyAwareAE}. Specifically, suppose that the discovered truth sensed value of a continuous event $e_j$ is $\rho_j$, and $u_i$'s sensed data of $e_j$ is $\hat \rho_{ij}$, then the event truth (confidence) and participant trustworthiness updating functions  can be:
\begin{equation}
	\rho_j = \frac{\sum_{u_i \in \mathcal U_{e_j}}\tau_i \cdot \hat \rho_{ij}}{\sum_{u_i \in \mathcal U_{e_j}}\tau_i}
	\label{eq:rho_function_cont}
\end{equation}
\begin{equation}
	\tau_i = \log(\sum_{u_i \in \mathcal U} \sum_{e_j \in \mathcal E_{u_i}} \frac{(\rho_j- \hat \rho_{ij})^2}{|\mathcal E_{u_i}|}) - \log(\sum_{e_j \in \mathcal E_{u_i}} \frac{(\rho_j- \hat \rho_{ij})^2}{|\mathcal E_{u_i}|})
	\label{eq:tau_function_cont}
\end{equation}
where $\mathcal U_{e_j}$ is the set of users who sense $e_j$, and $\mathcal E_{u_i}$ is the set of events that $u_i$ has sensed. For $\rho$-computation, following Sec.~\ref{sub:basic_rho_computation}, we can just adapt $d_{ij}$ and $s_{ij}$ according to Eq.~\ref{eq:rho_function_cont} (the participant $u_i \not \in \mathcal U_{e_j}$ can still send $d_{ij}=s_{ij}=0$ to protect her task completion information). For $\tau$-computation, Eq.~\ref{eq:tau_function_cont} requires $\sum_{u_i \in \mathcal U} \sum_{e_j \in \mathcal E_{u_i}} \frac{(\rho_j- \hat \rho_{ij})^2}{|\mathcal E_{u_i}|}$, which can be done with the same SSS-based method as $\rho$-computation. In particular, each participant $u_i$ can send $\sum_{e_j \in \mathcal E_{u_i}} \frac{(\rho_j- \hat \rho_{ij})^2}{|\mathcal E_{u_i}|}$ by secret shares, and then the server can compute the sum in a privacy-preserving manner. In a word, for continuous-value events, our mechanism can still work without revealing each participant's raw sensed data and completed tasks.



